diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index ff7e8a5..69838f8 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -145,6 +145,18 @@ set(GLideN64_SOURCES
   uCodes/Turbo3D.cpp
   uCodes/ZSort.cpp
   uCodes/ZSortBOSS.cpp
+  overlay/OverlayGL.cpp
+)
+
+# Emulator overlay menu sources (shared library)
+set(OVERLAY_COMMON_DIR "${CMAKE_CURRENT_SOURCE_DIR}/../../../../../all/common")
+# NOTE: include_directories for OVERLAY_COMMON_DIR is added after include_directories(. inc)
+# to avoid config.h name collision with GLideN64's Config.h on case-insensitive filesystems
+list(APPEND GLideN64_SOURCES
+  ${OVERLAY_COMMON_DIR}/emu_overlay.c
+  ${OVERLAY_COMMON_DIR}/emu_overlay_cfg.c
+  ${OVERLAY_COMMON_DIR}/emu_overlay_sdl.c
+  ${OVERLAY_COMMON_DIR}/cjson/cJSON.c
 )
 
 set(GLideNUI_SOURCES
@@ -235,7 +247,7 @@ if(EXISTS "${CMAKE_FIND_ROOT_PATH}/opt/vc/include/bcm_host.h" AND NOT MESA)
     "${CMAKE_FIND_ROOT_PATH}/opt/vc/lib/GL"
   )
 else(EXISTS "${CMAKE_FIND_ROOT_PATH}/opt/vc/include/bcm_host.h" AND NOT MESA)
-  set(EGL_LIB -lEGL)
+  set(EGL_LIB -ldl)
 endif(EXISTS "${CMAKE_FIND_ROOT_PATH}/opt/vc/include/bcm_host.h" AND NOT MESA)
 
 if(MUPENPLUSAPI)
@@ -244,6 +256,9 @@ if(MUPENPLUSAPI)
 		-DTXFILTER_LIB
   )
   include_directories( . inc )
+  include_directories(${OVERLAY_COMMON_DIR})
+  # SDL2 and SDL_ttf for overlay menu rendering
+  include_directories(${SDL_TTF_INCLUDE_DIRS})
   set(GLideN64_SOURCES_UNIX
 	MupenPlusPluginAPI.cpp
 	mupenplus/CommonAPIImpl_mupenplus.cpp
@@ -405,42 +420,45 @@ if(ANDROID)
 endif(ANDROID)
 
 if(NOT NO_OSD)
-  if(ANDROID)
-    set( FREETYPE_INCLUDE_DIRS "${ANDROID_LIB_PATH}/freetype/include" )
-  elseif(UNIX OR BCMHOST)
-    set( FREETYPE_INCLUDE_DIRS "/usr/include/freetype2/" )
-  else(UNIX OR BCMHOST)
-    set( ENV{FREETYPE_DIR} ${CMAKE_CURRENT_SOURCE_DIR}/../../freetype )
-  endif(ANDROID)
-
-  if(ANDROID)
-      add_library( ANDROID_FREETYPE
-              SHARED
-              IMPORTED )
-
-      if( GLIDEN64_BUILD_TYPE STREQUAL "Debug")
-          set( BUILD_VARIANT "debug" )
-      else()
-          set( BUILD_VARIANT "release" )
-      endif()
-
-      set_target_properties( # Specifies the target library.
-              ANDROID_FREETYPE
-
-              # Specifies the parameter you want to define.
-              PROPERTIES IMPORTED_LOCATION
-
-              # Provides the path to the library you want to import.
-              ${ANDROID_LIB_PATH}/libs/${BUILD_VARIANT}/${ANDROID_ABI}/libfreetype.so)
-      set(FREETYPE_LIBRARIES ANDROID_FREETYPE)
-  else(ANDROID)
-      FIND_PACKAGE( Freetype REQUIRED )
-      # presume a qt build linked to freetype
-      # will be used with mingw
-      if (NOT MUPENPLUSAPI AND MINGW)
-        set(FREETYPE_LIBRARIES "")
-      endif()
-  endif(ANDROID)
+  if(NOT FREETYPE_FOUND)
+    # FreeType not provided by toolchain — discover it
+    if(ANDROID)
+      set( FREETYPE_INCLUDE_DIRS "${ANDROID_LIB_PATH}/freetype/include" )
+    elseif(UNIX OR BCMHOST)
+      set( FREETYPE_INCLUDE_DIRS "/usr/include/freetype2/" )
+    else(UNIX OR BCMHOST)
+      set( ENV{FREETYPE_DIR} ${CMAKE_CURRENT_SOURCE_DIR}/../../freetype )
+    endif(ANDROID)
+
+    if(ANDROID)
+        add_library( ANDROID_FREETYPE
+                SHARED
+                IMPORTED )
+
+        if( GLIDEN64_BUILD_TYPE STREQUAL "Debug")
+            set( BUILD_VARIANT "debug" )
+        else()
+            set( BUILD_VARIANT "release" )
+        endif()
+
+        set_target_properties( # Specifies the target library.
+                ANDROID_FREETYPE
+
+                # Specifies the parameter you want to define.
+                PROPERTIES IMPORTED_LOCATION
+
+                # Provides the path to the library you want to import.
+                ${ANDROID_LIB_PATH}/libs/${BUILD_VARIANT}/${ANDROID_ABI}/libfreetype.so)
+        set(FREETYPE_LIBRARIES ANDROID_FREETYPE)
+    else(ANDROID)
+        FIND_PACKAGE( Freetype REQUIRED )
+        # presume a qt build linked to freetype
+        # will be used with mingw
+        if (NOT MUPENPLUSAPI AND MINGW)
+          set(FREETYPE_LIBRARIES "")
+        endif()
+    endif(ANDROID)
+  endif(NOT FREETYPE_FOUND)
 
   include_directories( ${FREETYPE_INCLUDE_DIRS} )
 else()
@@ -559,6 +577,10 @@ if("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU" OR "${CMAKE_CXX_COMPILER_ID}" MATCH
   set( CMAKE_SHARED_LINKER_FLAGS  "${CMAKE_SHARED_LINKER_FLAGS} ${GCC_STATIC_LINK_FLAGS}" )
 endif()
 
+# Use -Bsymbolic to prefer own statically-linked symbols (e.g. libpng)
+# over symbols from other shared libraries loaded in the process
+set( CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,-Bsymbolic" )
+
 set(CMAKE_CXX_STANDARD 17)
 set(CMAKE_CXX_STANDARD_REQUIRED YES)
 
@@ -628,6 +650,9 @@ else(GLIDEN64_BUILD_TYPE STREQUAL "Debug")
   endif(SDL)
 endif(GLIDEN64_BUILD_TYPE STREQUAL "Debug")
 
+# SDL2 + SDL_ttf + SDL_image for overlay menu rendering (needed regardless of SDL display mode)
+target_link_libraries(${GLideN64_DLL_NAME} -lSDL2 -lSDL2_ttf -lSDL2_image)
+
 if(UNIX AND NOT APPLE AND NOT ANDROID)
 	install(TARGETS ${GLideN64_DLL_NAME}
 		DESTINATION "${CMAKE_INSTALL_LIBDIR}/mupen64plus"
diff --git a/src/DisplayLoadProgress.cpp b/src/DisplayLoadProgress.cpp
index 647ca32..9a482c1 100644
--- a/src/DisplayLoadProgress.cpp
+++ b/src/DisplayLoadProgress.cpp
@@ -1,6 +1,7 @@
 #include <stdarg.h>
 #include <string.h>
 #include <cstdlib>
+#include <string>
 #include "GLideNHQ/TxFilterExport.h"
 #include <Graphics/Context.h>
 #include <Graphics/Parameters.h>
@@ -9,6 +10,17 @@
 #include "DisplayWindow.h"
 #include "DisplayLoadProgress.h"
 
+static const int MAX_LINES = 20;
+static std::string s_lines[MAX_LINES];
+static int s_lineCount = 0;
+static bool s_hiresMode = false;
+static bool s_loadProgressActive = false;
+
+bool isLoadProgressActive()
+{
+	return s_loadProgressActive;
+}
+
 void displayLoadProgress(const wchar_t *format, ...)
 {
 	va_list args;
@@ -34,14 +46,65 @@ void displayLoadProgress(const wchar_t *format, ...)
 	// XXX: convert to multibyte
 	wcstombs(buf, wbuf, INFO_BUF);
 
+	// Strip trailing newline
+	size_t len = strlen(buf);
+	while (len > 0 && (buf[len - 1] == '\n' || buf[len - 1] == '\r'))
+		buf[--len] = '\0';
+
+	// Empty message clears everything
+	if (len == 0) {
+		s_lineCount = 0;
+		s_hiresMode = false;
+		s_loadProgressActive = false;
+	} else {
+		s_loadProgressActive = true;
+		// Detect hi-res texture loading messages: "[N] total mem:"
+		if (strstr(buf, "total mem:") != nullptr) {
+			s_hiresMode = true;
+		} else {
+			// Any other message resets to single-line mode
+			s_hiresMode = false;
+			s_lineCount = 0;
+		}
+
+		// Add to scrolling history (shift up when full)
+		if (s_lineCount >= MAX_LINES) {
+			for (int i = 0; i < MAX_LINES - 1; i++)
+				s_lines[i] = s_lines[i + 1];
+			s_lines[MAX_LINES - 1] = buf;
+		} else {
+			s_lines[s_lineCount++] = buf;
+		}
+	}
+
+	// Render
 	FrameBuffer* pBuffer = frameBufferList().getCurrent();
 	if (pBuffer != nullptr)
 		gfxContext.bindFramebuffer(graphics::bufferTarget::DRAW_FRAMEBUFFER, graphics::ObjectHandle::defaultFramebuffer);
 
 	GraphicsDrawer & drawer = dwnd().getDrawer();
 	drawer.clearColorBuffer(nullptr);
-	if (strlen(buf) > 0)
-		drawer.drawText(buf, -0.9f, 0);
+
+	if (s_lineCount > 0) {
+		const float lineHeight = 2.0f * 24.0f / static_cast<float>(dwnd().getHeight());
+		const int titleLines = s_hiresMode ? 1 : 0;
+		const float titleExtra = s_hiresMode ? 0.5f : 0.0f;
+		const float totalHeight = (titleLines + titleExtra + s_lineCount) * lineHeight;
+
+		// Center vertically
+		float y = totalHeight / 2.0f;
+
+		if (s_hiresMode) {
+			drawer.drawText("Processing hi-res textures (first time only)...", -0.9f, y);
+			y -= lineHeight * 1.5f;
+		}
+
+		for (int i = 0; i < s_lineCount; i++) {
+			drawer.drawText(s_lines[i].c_str(), -0.9f, y);
+			y -= lineHeight;
+		}
+	}
+
 	dwnd().swapBuffers();
 
 	if (pBuffer != nullptr)
diff --git a/src/DisplayLoadProgress.h b/src/DisplayLoadProgress.h
index 701d27d..e6ad4c8 100644
--- a/src/DisplayLoadProgress.h
+++ b/src/DisplayLoadProgress.h
@@ -2,5 +2,6 @@
 #define DISPLAYLOADPROGRESS_H
 
 void displayLoadProgress(const wchar_t *format, ...);
+bool isLoadProgressActive();
 
 #endif // DISPLAYLOADPROGRESS_H
diff --git a/src/DisplayWindow.cpp b/src/DisplayWindow.cpp
index 59725f6..5cc6fc1 100644
--- a/src/DisplayWindow.cpp
+++ b/src/DisplayWindow.cpp
@@ -1,5 +1,7 @@
 #include <assert.h>
 #include <cstdlib>
+#include <cstring>
+#include <cstdio>
 #include "Config.h"
 #include "RSP.h"
 #include "VI.h"
@@ -8,6 +10,261 @@
 #include "PluginAPI.h"
 #include "FrameBuffer.h"
 
+#include <GLES3/gl3.h>
+#include <SDL2/SDL.h>
+#include <functional>
+extern "C" {
+#include "emu_overlay.h"
+#include "emu_overlay_cfg.h"
+#include "emu_overlay_sdl.h"
+}
+#include "mupenplus/GLideN64_mupenplus.h"
+#include "Graphics/OpenGLContext/ThreadedOpenGl/opengl_Wrapper.h"
+#include "DisplayLoadProgress.h"
+
+namespace opengl {
+class OverlayCallbackCommand : public OpenGlCommand {
+public:
+	OverlayCallbackCommand() : OpenGlCommand(true, false, "OverlayCallback", false) {}
+
+	static std::shared_ptr<OpenGlCommand> get(std::function<void()> callback) {
+		static int poolId = OpenGlCommandPool::get().getNextAvailablePool();
+		auto ptr = getFromPool<OverlayCallbackCommand>(poolId);
+		ptr->m_callback = std::move(callback);
+		return ptr;
+	}
+
+	void commandToExecute() override {
+		m_callback();
+		m_callback = nullptr; // release captured state promptly
+	}
+private:
+	std::function<void()> m_callback;
+};
+}
+
+// ---------------------------------------------------------------------------
+// Overlay state
+// ---------------------------------------------------------------------------
+
+static EmuOvl s_overlay;
+static EmuOvlConfig s_overlayConfig;
+static bool s_overlayInitialized = false;
+static bool s_overlayConfigLoaded = false;
+static bool s_overlayConfigFailed = false;
+static char s_overlayJsonPath[512] = "";
+static char s_overlayIniPath[512] = "";
+static bool s_menuBtnPrev = false;
+static SDL_Joystick* s_joy = nullptr;
+static Uint8 s_prevHat = 0;
+static Uint32 s_prevButtons = 0;
+
+// ---------------------------------------------------------------------------
+// Overlay helpers
+// ---------------------------------------------------------------------------
+
+static void overlay_init_paths()
+{
+	const char* json = getenv("EMU_OVERLAY_JSON");
+	const char* ini  = getenv("EMU_OVERLAY_INI");
+	if (json) strncpy(s_overlayJsonPath, json, sizeof(s_overlayJsonPath) - 1);
+	if (ini)  strncpy(s_overlayIniPath,  ini,  sizeof(s_overlayIniPath) - 1);
+}
+
+static void overlay_ensure_init(int w, int h)
+{
+	if (s_overlayInitialized || s_overlayConfigFailed)
+		return;
+
+	// Load config once (permanent failure if config file is bad)
+	if (!s_overlayConfigLoaded) {
+		overlay_init_paths();
+
+		if (s_overlayJsonPath[0] == '\0')
+			return; // no overlay config provided
+
+		memset(&s_overlayConfig, 0, sizeof(s_overlayConfig));
+		if (emu_ovl_cfg_load(&s_overlayConfig, s_overlayJsonPath) != 0) {
+			fprintf(stderr, "[Overlay] Failed to load config: %s\n", s_overlayJsonPath);
+			s_overlayConfigFailed = true;
+			return;
+		}
+
+		if (s_overlayIniPath[0] != '\0') {
+			emu_ovl_cfg_read_ini(&s_overlayConfig, s_overlayIniPath);
+		}
+
+		s_overlayConfigLoaded = true;
+	}
+
+	// Try GL init on the video thread (retries each frame until GL context is available)
+	int initResult = -1;
+	EmuOvlRenderBackend* render = overlay_sdl_get_backend();
+	const char* gameName = getenv("EMU_OVERLAY_GAME");
+
+	// [&] capture is safe: executeOverlayCommand blocks until the callback completes
+	// (synced command), so all local variables remain alive for the duration.
+	opengl::FunctionWrapper::executeOverlayCommand(
+		opengl::OverlayCallbackCommand::get([&]() {
+			if (render->init(w, h) != 0) {
+				initResult = -1;
+				return;
+			}
+			emu_ovl_init(&s_overlay, &s_overlayConfig, render,
+			             gameName ? gameName : "N64", w, h);
+			initResult = 0;
+		})
+	);
+
+	if (initResult != 0)
+		return; // GL not ready yet, will retry next frame
+
+	s_overlayInitialized = true;
+	fprintf(stderr, "[Overlay] Initialized successfully (%dx%d)\n", w, h);
+}
+
+static bool check_menu_button()
+{
+	SDL_JoystickUpdate();
+
+	if (!s_joy) {
+		if (SDL_NumJoysticks() > 0)
+			s_joy = SDL_JoystickOpen(0);
+		if (!s_joy)
+			return false;
+	}
+
+	bool pressed = SDL_JoystickGetButton(s_joy, 8) != 0;
+	bool justPressed = pressed && !s_menuBtnPrev;
+	s_menuBtnPrev = pressed;
+	return justPressed;
+}
+
+static EmuOvlInput poll_overlay_input()
+{
+	EmuOvlInput input;
+	memset(&input, 0, sizeof(input));
+
+	// Use direct state polling instead of SDL events — SDL_PollEvent() may not
+	// deliver joystick events reliably in mupen64plus's threaded plugin context.
+	SDL_JoystickUpdate();
+	if (!s_joy) return input;
+
+	// D-pad (hat) — edge detect: only trigger on newly-pressed directions
+	Uint8 hat = SDL_JoystickGetHat(s_joy, 0);
+	Uint8 hatPressed = hat & ~s_prevHat;
+	s_prevHat = hat;
+
+	if (hatPressed & SDL_HAT_UP)    input.up    = true;
+	if (hatPressed & SDL_HAT_DOWN)  input.down  = true;
+	if (hatPressed & SDL_HAT_LEFT)  input.left  = true;
+	if (hatPressed & SDL_HAT_RIGHT) input.right = true;
+
+	// Buttons — edge detect: only trigger on newly-pressed buttons
+	// SDL button indices: 0=A(hw), 1=B(hw), 2=X(hw), 3=Y(hw), 4=L1, 5=R1, 8=Menu
+	static const int btnMap[] = {0, 1, 4, 5, 8};
+	Uint32 curButtons = 0;
+	for (int i = 0; i < 5; i++) {
+		if (SDL_JoystickGetButton(s_joy, btnMap[i]))
+			curButtons |= (1u << btnMap[i]);
+	}
+	Uint32 btnPressed = curButtons & ~s_prevButtons;
+	s_prevButtons = curButtons;
+
+	if (btnPressed & (1u << 0)) input.b    = true;
+	if (btnPressed & (1u << 1)) input.a    = true;
+	if (btnPressed & (1u << 4)) input.l1   = true;
+	if (btnPressed & (1u << 5)) input.r1   = true;
+	if (btnPressed & (1u << 8)) input.menu = true;
+
+	return input;
+}
+
+static EmuOvlAction run_overlay_loop(DisplayWindow& wnd)
+{
+	EmuOvlRenderBackend* render = s_overlay.render;
+
+	// Pause audio (stays on main thread)
+	SDL_PauseAudio(1);
+
+	if (opengl::FunctionWrapper::isThreadedMode()) {
+		// Threaded mode: SDL input must be polled on the main thread (the thread
+		// that initialized SDL). GL calls are dispatched per-frame to the video thread.
+
+		// Open overlay on video thread (captures current frame — needs GL)
+		opengl::FunctionWrapper::executeOverlayCommand(
+			opengl::OverlayCallbackCommand::get([&]() {
+				emu_ovl_open(&s_overlay);
+			})
+		);
+
+		// Reset input edge detection state and drain pending SDL events
+		s_prevHat = SDL_JoystickGetHat(s_joy, 0);
+		s_prevButtons = 0;
+		for (int i : {0, 1, 4, 5, 8}) {
+			if (SDL_JoystickGetButton(s_joy, i))
+				s_prevButtons |= (1u << i);
+		}
+		SDL_Event ev;
+		while (SDL_PollEvent(&ev)) {}
+		s_menuBtnPrev = true; // prevent re-trigger
+
+		// Menu loop: input on main thread, render on video thread
+		while (emu_ovl_is_active(&s_overlay)) {
+			EmuOvlInput input = poll_overlay_input();
+
+			// Dispatch update + render + swap to video thread.
+			// [&] capture safe: executeOverlayCommand blocks until complete.
+			opengl::FunctionWrapper::executeOverlayCommand(
+				opengl::OverlayCallbackCommand::get([&]() {
+					emu_ovl_update(&s_overlay, &input);
+					emu_ovl_render(&s_overlay);
+					// Raw function pointer — avoids deadlock (see comment in non-threaded path)
+					::CoreVideo_GL_SwapBuffers();
+				})
+			);
+
+			SDL_Delay(16);
+		}
+	} else {
+		// Non-threaded mode: everything runs on the main thread
+		emu_ovl_open(&s_overlay);
+
+		s_prevHat = SDL_JoystickGetHat(s_joy, 0);
+		s_prevButtons = 0;
+		for (int i : {0, 1, 4, 5, 8}) {
+			if (SDL_JoystickGetButton(s_joy, i))
+				s_prevButtons |= (1u << i);
+		}
+		SDL_Event ev;
+		while (SDL_PollEvent(&ev)) {}
+		s_menuBtnPrev = true;
+
+		while (emu_ovl_is_active(&s_overlay)) {
+			EmuOvlInput input = poll_overlay_input();
+			emu_ovl_update(&s_overlay, &input);
+			emu_ovl_render(&s_overlay);
+			CoreVideo_GL_SwapBuffers();
+			SDL_Delay(16);
+		}
+	}
+
+	// Resume audio (stays on main thread)
+	SDL_PauseAudio(0);
+
+	EmuOvlAction action = emu_ovl_get_action(&s_overlay);
+
+	// Handle config changes: write to INI first (while dirty flags are set), then apply
+	if (emu_ovl_cfg_has_changes(&s_overlayConfig)) {
+		if (s_overlayIniPath[0] != '\0') {
+			emu_ovl_cfg_write_ini(&s_overlayConfig, s_overlayIniPath);
+		}
+		emu_ovl_cfg_apply_staged(&s_overlayConfig);
+	}
+
+	return action;
+}
+
 bool DisplayWindow::start()
 {
 	if (!_start())
@@ -48,6 +305,32 @@ void DisplayWindow::swapBuffers()
 {
 	m_drawer.drawOSD();
 	m_drawer.clearStatistics();
+
+	// Skip overlay during texture loading (prevents GL state corruption and
+	// avoids confusing overlay menu while hi-res textures are being indexed)
+	if (!isLoadProgressActive()) {
+		overlay_ensure_init(getScreenWidth(), getScreenHeight());
+		if (s_overlayInitialized && check_menu_button()) {
+			EmuOvlAction action = run_overlay_loop(*this);
+			if (action == EMU_OVL_ACTION_QUIT) {
+				if (CoreDoCommand)
+					CoreDoCommand(M64CMD_STOP, 0, nullptr);
+			} else if (action == EMU_OVL_ACTION_SAVE_STATE) {
+				int slot = emu_ovl_get_action_param(&s_overlay);
+				if (CoreDoCommand) {
+					CoreDoCommand(M64CMD_STATE_SET_SLOT, slot, nullptr);
+					CoreDoCommand(M64CMD_STATE_SAVE, 1, nullptr);
+				}
+				emu_ovl_save_slot_screenshot(&s_overlay, slot);
+			} else if (action == EMU_OVL_ACTION_LOAD_STATE) {
+				if (CoreDoCommand) {
+					CoreDoCommand(M64CMD_STATE_SET_SLOT, emu_ovl_get_action_param(&s_overlay), nullptr);
+					CoreDoCommand(M64CMD_STATE_LOAD, 0, nullptr);
+				}
+			}
+		}
+	}
+
 	_swapBuffers();
 	if (!RSP.LLE) {
 		if ((config.generalEmulation.hacks & hack_doNotResetOtherModeL) == 0)
diff --git a/src/GLideNHQ/inc/png.h b/src/GLideNHQ/inc/png.h
index 51ac8ab..83d3903 100644
--- a/src/GLideNHQ/inc/png.h
+++ b/src/GLideNHQ/inc/png.h
@@ -1,68 +1,105 @@
 
 /* png.h - header file for PNG reference library
  *
- * libpng version 1.6.32, August 24, 2017
+ * libpng version 1.6.43
  *
- * Copyright (c) 1998-2002,2004,2006-2017 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ * Copyright (c) 2018-2024 Cosmin Truta
+ * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
+ * Copyright (c) 1996-1997 Andreas Dilger
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
- * This code is released under the libpng license (See LICENSE, below)
+ * This code is released under the libpng license. (See LICENSE, below.)
  *
  * Authors and maintainers:
  *   libpng versions 0.71, May 1995, through 0.88, January 1996: Guy Schalnat
  *   libpng versions 0.89, June 1996, through 0.96, May 1997: Andreas Dilger
- *   libpng versions 0.97, January 1998, through 1.6.32, August 24, 2017:
- *     Glenn Randers-Pehrson.
+ *   libpng versions 0.97, January 1998, through 1.6.35, July 2018:
+ *     Glenn Randers-Pehrson
+ *   libpng versions 1.6.36, December 2018, through 1.6.43, February 2024:
+ *     Cosmin Truta
  *   See also "Contributing Authors", below.
  */
 
 /*
- * COPYRIGHT NOTICE, DISCLAIMER, and LICENSE:
+ * COPYRIGHT NOTICE, DISCLAIMER, and LICENSE
+ * =========================================
+ *
+ * PNG Reference Library License version 2
+ * ---------------------------------------
+ *
+ *  * Copyright (c) 1995-2024 The PNG Reference Library Authors.
+ *  * Copyright (c) 2018-2024 Cosmin Truta.
+ *  * Copyright (c) 2000-2002, 2004, 2006-2018 Glenn Randers-Pehrson.
+ *  * Copyright (c) 1996-1997 Andreas Dilger.
+ *  * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
+ *
+ * The software is supplied "as is", without warranty of any kind,
+ * express or implied, including, without limitation, the warranties
+ * of merchantability, fitness for a particular purpose, title, and
+ * non-infringement.  In no event shall the Copyright owners, or
+ * anyone distributing the software, be liable for any damages or
+ * other liability, whether in contract, tort or otherwise, arising
+ * from, out of, or in connection with the software, or the use or
+ * other dealings in the software, even if advised of the possibility
+ * of such damage.
+ *
+ * Permission is hereby granted to use, copy, modify, and distribute
+ * this software, or portions hereof, for any purpose, without fee,
+ * subject to the following restrictions:
+ *
+ *  1. The origin of this software must not be misrepresented; you
+ *     must not claim that you wrote the original software.  If you
+ *     use this software in a product, an acknowledgment in the product
+ *     documentation would be appreciated, but is not required.
  *
- * If you modify libpng you may insert additional notices immediately following
- * this sentence.
+ *  2. Altered source versions must be plainly marked as such, and must
+ *     not be misrepresented as being the original software.
  *
- * This code is released under the libpng license.
+ *  3. This Copyright notice may not be removed or altered from any
+ *     source or altered source distribution.
  *
- * libpng versions 1.0.7, July 1, 2000 through 1.6.32, August 24, 2017 are
- * Copyright (c) 2000-2002, 2004, 2006-2017 Glenn Randers-Pehrson, are
+ *
+ * PNG Reference Library License version 1 (for libpng 0.5 through 1.6.35)
+ * -----------------------------------------------------------------------
+ *
+ * libpng versions 1.0.7, July 1, 2000, through 1.6.35, July 15, 2018 are
+ * Copyright (c) 2000-2002, 2004, 2006-2018 Glenn Randers-Pehrson, are
  * derived from libpng-1.0.6, and are distributed according to the same
  * disclaimer and license as libpng-1.0.6 with the following individuals
  * added to the list of Contributing Authors:
  *
- *    Simon-Pierre Cadieux
- *    Eric S. Raymond
- *    Mans Rullgard
- *    Cosmin Truta
- *    Gilles Vollant
- *    James Yu
- *    Mandar Sahastrabuddhe
- *    Google Inc.
- *    Vadim Barkov
+ *     Simon-Pierre Cadieux
+ *     Eric S. Raymond
+ *     Mans Rullgard
+ *     Cosmin Truta
+ *     Gilles Vollant
+ *     James Yu
+ *     Mandar Sahastrabuddhe
+ *     Google Inc.
+ *     Vadim Barkov
  *
  * and with the following additions to the disclaimer:
  *
- *    There is no warranty against interference with your enjoyment of the
- *    library or against infringement.  There is no warranty that our
- *    efforts or the library will fulfill any of your particular purposes
- *    or needs.  This library is provided with all faults, and the entire
- *    risk of satisfactory quality, performance, accuracy, and effort is with
- *    the user.
+ *     There is no warranty against interference with your enjoyment of
+ *     the library or against infringement.  There is no warranty that our
+ *     efforts or the library will fulfill any of your particular purposes
+ *     or needs.  This library is provided with all faults, and the entire
+ *     risk of satisfactory quality, performance, accuracy, and effort is
+ *     with the user.
  *
  * Some files in the "contrib" directory and some configure-generated
- * files that are distributed with libpng have other copyright owners and
+ * files that are distributed with libpng have other copyright owners, and
  * are released under other open source licenses.
  *
  * libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are
  * Copyright (c) 1998-2000 Glenn Randers-Pehrson, are derived from
  * libpng-0.96, and are distributed according to the same disclaimer and
- * license as libpng-0.96, with the following individuals added to the list
- * of Contributing Authors:
+ * license as libpng-0.96, with the following individuals added to the
+ * list of Contributing Authors:
  *
- *    Tom Lane
- *    Glenn Randers-Pehrson
- *    Willem van Schaik
+ *     Tom Lane
+ *     Glenn Randers-Pehrson
+ *     Willem van Schaik
  *
  * libpng versions 0.89, June 1996, through 0.96, May 1997, are
  * Copyright (c) 1996-1997 Andreas Dilger, are derived from libpng-0.88,
@@ -70,14 +107,14 @@
  * libpng-0.88, with the following individuals added to the list of
  * Contributing Authors:
  *
- *    John Bowler
- *    Kevin Bracey
- *    Sam Bushell
- *    Magnus Holmgren
- *    Greg Roelofs
- *    Tom Tanner
+ *     John Bowler
+ *     Kevin Bracey
+ *     Sam Bushell
+ *     Magnus Holmgren
+ *     Greg Roelofs
+ *     Tom Tanner
  *
- * Some files in the "scripts" directory have other copyright owners
+ * Some files in the "scripts" directory have other copyright owners,
  * but are released under this license.
  *
  * libpng versions 0.5, May 1995, through 0.88, January 1996, are
@@ -86,62 +123,49 @@
  * For the purposes of this copyright and license, "Contributing Authors"
  * is defined as the following set of individuals:
  *
- *    Andreas Dilger
- *    Dave Martindale
- *    Guy Eric Schalnat
- *    Paul Schmidt
- *    Tim Wegner
- *
- * The PNG Reference Library is supplied "AS IS".  The Contributing Authors
- * and Group 42, Inc. disclaim all warranties, expressed or implied,
- * including, without limitation, the warranties of merchantability and of
- * fitness for any purpose.  The Contributing Authors and Group 42, Inc.
- * assume no liability for direct, indirect, incidental, special, exemplary,
- * or consequential damages, which may result from the use of the PNG
- * Reference Library, even if advised of the possibility of such damage.
+ *     Andreas Dilger
+ *     Dave Martindale
+ *     Guy Eric Schalnat
+ *     Paul Schmidt
+ *     Tim Wegner
+ *
+ * The PNG Reference Library is supplied "AS IS".  The Contributing
+ * Authors and Group 42, Inc. disclaim all warranties, expressed or
+ * implied, including, without limitation, the warranties of
+ * merchantability and of fitness for any purpose.  The Contributing
+ * Authors and Group 42, Inc. assume no liability for direct, indirect,
+ * incidental, special, exemplary, or consequential damages, which may
+ * result from the use of the PNG Reference Library, even if advised of
+ * the possibility of such damage.
  *
  * Permission is hereby granted to use, copy, modify, and distribute this
  * source code, or portions hereof, for any purpose, without fee, subject
  * to the following restrictions:
  *
- *   1. The origin of this source code must not be misrepresented.
+ *  1. The origin of this source code must not be misrepresented.
  *
- *   2. Altered versions must be plainly marked as such and must not
- *      be misrepresented as being the original source.
+ *  2. Altered versions must be plainly marked as such and must not
+ *     be misrepresented as being the original source.
  *
- *   3. This Copyright notice may not be removed or altered from any
- *      source or altered source distribution.
+ *  3. This Copyright notice may not be removed or altered from any
+ *     source or altered source distribution.
  *
- * The Contributing Authors and Group 42, Inc. specifically permit, without
- * fee, and encourage the use of this source code as a component to
- * supporting the PNG file format in commercial products.  If you use this
- * source code in a product, acknowledgment is not required but would be
- * appreciated.
+ * The Contributing Authors and Group 42, Inc. specifically permit,
+ * without fee, and encourage the use of this source code as a component
+ * to supporting the PNG file format in commercial products.  If you use
+ * this source code in a product, acknowledgment is not required but would
+ * be appreciated.
  *
  * END OF COPYRIGHT NOTICE, DISCLAIMER, and LICENSE.
  *
- * TRADEMARK:
+ * TRADEMARK
+ * =========
  *
- * The name "libpng" has not been registered by the Copyright owner
+ * The name "libpng" has not been registered by the Copyright owners
  * as a trademark in any jurisdiction.  However, because libpng has
  * been distributed and maintained world-wide, continually since 1995,
- * the Copyright owner claims "common-law trademark protection" in any
+ * the Copyright owners claim "common-law trademark protection" in any
  * jurisdiction where common-law trademark is recognized.
- *
- * OSI CERTIFICATION:
- *
- * Libpng is OSI Certified Open Source Software.  OSI Certified Open Source is
- * a certification mark of the Open Source Initiative. OSI has not addressed
- * the additional disclaimers inserted at version 1.0.7.
- *
- * EXPORT CONTROL:
- *
- * The Copyright owner believes that the Export Control Classification
- * Number (ECCN) for libpng is EAR99, which means not subject to export
- * controls or International Traffic in Arms Regulations (ITAR) because
- * it is open source, publicly available software, that does not contain
- * any encryption software.  See the EAR, paragraphs 734.3(b)(3) and
- * 734.7(b).
  */
 
 /*
@@ -207,91 +231,33 @@
  *    1.0.7rc1-2               1    10007  2.1.0.7rc1-2 (binary compatible)
  *    1.0.7                    1    10007  (still compatible)
  *    ...
- *    1.0.19                  10    10019  10.so.0.19[.0]
+ *    1.0.69                  10    10069  10.so.0.69[.0]
+ *    ...
+ *    1.2.59                  13    10259  12.so.0.59[.0]
  *    ...
- *    1.2.57                  13    10257  12.so.0.57[.0]
+ *    1.4.20                  14    10420  14.so.0.20[.0]
  *    ...
- *    1.5.28                  15    10527  15.so.15.28[.0]
+ *    1.5.30                  15    10530  15.so.15.30[.0]
  *    ...
- *    1.6.32                  16    10632  16.so.16.32[.0]
- *
- *    Henceforth the source version will match the shared-library major
- *    and minor numbers; the shared-library major version number will be
- *    used for changes in backward compatibility, as it is intended.  The
- *    PNG_LIBPNG_VER macro, which is not used within libpng but is available
- *    for applications, is an unsigned integer of the form xyyzz corresponding
- *    to the source version x.y.z (leading zeros in y and z).  Beta versions
- *    were given the previous public release number plus a letter, until
- *    version 1.0.6j; from then on they were given the upcoming public
- *    release number plus "betaNN" or "rcNN".
+ *    1.6.43                  16    10643  16.so.16.43[.0]
+ *
+ *    Henceforth the source version will match the shared-library major and
+ *    minor numbers; the shared-library major version number will be used for
+ *    changes in backward compatibility, as it is intended.
+ *    The PNG_LIBPNG_VER macro, which is not used within libpng but is
+ *    available for applications, is an unsigned integer of the form XYYZZ
+ *    corresponding to the source version X.Y.Z (leading zeros in Y and Z).
+ *    Beta versions were given the previous public release number plus a
+ *    letter, until version 1.0.6j; from then on they were given the upcoming
+ *    public release number plus "betaNN" or "rcNN".
  *
  *    Binary incompatibility exists only when applications make direct access
  *    to the info_ptr or png_ptr members through png.h, and the compiled
  *    application is loaded with a different version of the library.
  *
- *    DLLNUM will change each time there are forward or backward changes
- *    in binary compatibility (e.g., when a new feature is added).
- *
  * See libpng.txt or libpng.3 for more information.  The PNG specification
- * is available as a W3C Recommendation and as an ISO Specification,
- * <https://www.w3.org/TR/2003/REC-PNG-20031110/
- */
-
-/*
- * Y2K compliance in libpng:
- * =========================
- *
- *    August 24, 2017
- *
- *    Since the PNG Development group is an ad-hoc body, we can't make
- *    an official declaration.
- *
- *    This is your unofficial assurance that libpng from version 0.71 and
- *    upward through 1.6.32 are Y2K compliant.  It is my belief that
- *    earlier versions were also Y2K compliant.
- *
- *    Libpng only has two year fields.  One is a 2-byte unsigned integer
- *    that will hold years up to 65535.  The other, which is deprecated,
- *    holds the date in text format, and will hold years up to 9999.
- *
- *    The integer is
- *        "png_uint_16 year" in png_time_struct.
- *
- *    The string is
- *        "char time_buffer[29]" in png_struct.  This is no longer used
- *    in libpng-1.6.x and will be removed from libpng-1.7.0.
- *
- *    There are seven time-related functions:
- *        png.c: png_convert_to_rfc_1123_buffer() in png.c
- *          (formerly png_convert_to_rfc_1123() prior to libpng-1.5.x and
- *          png_convert_to_rfc_1152() in error prior to libpng-0.98)
- *        png_convert_from_struct_tm() in pngwrite.c, called in pngwrite.c
- *        png_convert_from_time_t() in pngwrite.c
- *        png_get_tIME() in pngget.c
- *        png_handle_tIME() in pngrutil.c, called in pngread.c
- *        png_set_tIME() in pngset.c
- *        png_write_tIME() in pngwutil.c, called in pngwrite.c
- *
- *    All handle dates properly in a Y2K environment.  The
- *    png_convert_from_time_t() function calls gmtime() to convert from system
- *    clock time, which returns (year - 1900), which we properly convert to
- *    the full 4-digit year.  There is a possibility that libpng applications
- *    are not passing 4-digit years into the png_convert_to_rfc_1123_buffer()
- *    function, or that they are incorrectly passing only a 2-digit year
- *    instead of "year - 1900" into the png_convert_from_struct_tm() function,
- *    but this is not under our control.  The libpng documentation has always
- *    stated that it works with 4-digit years, and the APIs have been
- *    documented as such.
- *
- *    The tIME chunk itself is also Y2K compliant.  It uses a 2-byte unsigned
- *    integer to hold the year, and can hold years as large as 65535.
- *
- *    zlib, upon which libpng depends, is also Y2K compliant.  It contains
- *    no date-related code.
- *
- *       Glenn Randers-Pehrson
- *       libpng maintainer
- *       PNG Development Group
+ * is available as a W3C Recommendation and as an ISO/IEC Standard; see
+ * <https://www.w3.org/TR/2003/REC-PNG-20031110/>
  */
 
 #ifndef PNG_H
@@ -309,21 +275,22 @@
  */
 
 /* Version information for png.h - this should match the version in png.c */
-#define PNG_LIBPNG_VER_STRING "1.6.32"
-#define PNG_HEADER_VERSION_STRING " libpng version 1.6.32 - August 24, 2017\n"
+#define PNG_LIBPNG_VER_STRING "1.6.43"
+#define PNG_HEADER_VERSION_STRING " libpng version " PNG_LIBPNG_VER_STRING "\n"
 
-#define PNG_LIBPNG_VER_SONUM   16
-#define PNG_LIBPNG_VER_DLLNUM  16
+/* The versions of shared library builds should stay in sync, going forward */
+#define PNG_LIBPNG_VER_SHAREDLIB 16
+#define PNG_LIBPNG_VER_SONUM     PNG_LIBPNG_VER_SHAREDLIB /* [Deprecated] */
+#define PNG_LIBPNG_VER_DLLNUM    PNG_LIBPNG_VER_SHAREDLIB /* [Deprecated] */
 
 /* These should match the first 3 components of PNG_LIBPNG_VER_STRING: */
 #define PNG_LIBPNG_VER_MAJOR   1
 #define PNG_LIBPNG_VER_MINOR   6
-#define PNG_LIBPNG_VER_RELEASE 32
+#define PNG_LIBPNG_VER_RELEASE 43
 
-/* This should match the numeric part of the final component of
- * PNG_LIBPNG_VER_STRING, omitting any leading zero:
+/* This should be zero for a public release, or non-zero for a
+ * development version.
  */
-
 #define PNG_LIBPNG_VER_BUILD  0
 
 /* Release Status */
@@ -343,13 +310,14 @@
 
 #define PNG_LIBPNG_BUILD_BASE_TYPE PNG_LIBPNG_BUILD_STABLE
 
-/* Careful here.  At one time, Guy wanted to use 082, but that would be octal.
- * We must not include leading zeros.
- * Versions 0.7 through 1.0.0 were in the range 0 to 100 here (only
- * version 1.0.0 was mis-numbered 100 instead of 10000).  From
- * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release
+/* Careful here.  At one time, Guy wanted to use 082, but that
+ * would be octal.  We must not include leading zeros.
+ * Versions 0.7 through 1.0.0 were in the range 0 to 100 here
+ * (only version 1.0.0 was mis-numbered 100 instead of 10000).
+ * From version 1.0.1 it is:
+ * XXYYZZ, where XX=major, YY=minor, ZZ=release
  */
-#define PNG_LIBPNG_VER 10632 /* 1.6.32 */
+#define PNG_LIBPNG_VER 10643 /* 1.6.43 */
 
 /* Library configuration: these options cannot be changed after
  * the library has been built.
@@ -459,7 +427,7 @@ extern "C" {
 /* This triggers a compiler error in png.c, if png.c and png.h
  * do not agree upon the version number.
  */
-typedef char* png_libpng_version_1_6_32;
+typedef char* png_libpng_version_1_6_43;
 
 /* Basic control structions.  Read libpng-manual.txt or libpng.3 for more info.
  *
@@ -600,8 +568,8 @@ typedef struct png_text_struct
    png_charp key;          /* keyword, 1-79 character description of "text" */
    png_charp text;         /* comment, may be an empty string (ie "")
                               or a NULL pointer */
-   png_size_t text_length; /* length of the text string */
-   png_size_t itxt_length; /* length of the itxt string */
+   size_t text_length;     /* length of the text string */
+   size_t itxt_length;     /* length of the itxt string */
    png_charp lang;         /* language code, 0-79 characters
                               or a NULL pointer */
    png_charp lang_key;     /* keyword translated UTF-8 string, 0 or more
@@ -654,7 +622,7 @@ typedef struct png_unknown_chunk_t
 {
    png_byte name[5]; /* Textual chunk name with '\0' terminator */
    png_byte *data;   /* Data, should not be modified on read! */
-   png_size_t size;
+   size_t size;
 
    /* On write 'location' must be set using the flag values listed below.
     * Notice that on read it is set by libpng however the values stored have
@@ -679,7 +647,7 @@ typedef png_unknown_chunk * * png_unknown_chunkpp;
 /* Maximum positive integer used in PNG is (2^31)-1 */
 #define PNG_UINT_31_MAX ((png_uint_32)0x7fffffffL)
 #define PNG_UINT_32_MAX ((png_uint_32)(-1))
-#define PNG_SIZE_MAX ((png_size_t)(-1))
+#define PNG_SIZE_MAX ((size_t)(-1))
 
 /* These are constants for fixed point values encoded in the
  * PNG specification manner (x100000)
@@ -785,7 +753,7 @@ typedef png_unknown_chunk * * png_unknown_chunkpp;
 typedef struct png_row_info_struct
 {
    png_uint_32 width;    /* width of row */
-   png_size_t rowbytes;  /* number of bytes in row */
+   size_t rowbytes;      /* number of bytes in row */
    png_byte color_type;  /* color type of row */
    png_byte bit_depth;   /* bit depth of row */
    png_byte channels;    /* number of channels (1, 2, 3, or 4) */
@@ -804,7 +772,7 @@ typedef png_row_info * * png_row_infopp;
  * expected to return the read data in the buffer.
  */
 typedef PNG_CALLBACK(void, *png_error_ptr, (png_structp, png_const_charp));
-typedef PNG_CALLBACK(void, *png_rw_ptr, (png_structp, png_bytep, png_size_t));
+typedef PNG_CALLBACK(void, *png_rw_ptr, (png_structp, png_bytep, size_t));
 typedef PNG_CALLBACK(void, *png_flush_ptr, (png_structp));
 typedef PNG_CALLBACK(void, *png_read_status_ptr, (png_structp, png_uint_32,
     int));
@@ -880,7 +848,7 @@ PNG_FUNCTION(void, (PNGCAPI *png_longjmp_ptr), PNGARG((jmp_buf, int)), typedef);
 #define PNG_TRANSFORM_GRAY_TO_RGB   0x2000      /* read only */
 /* Added to libpng-1.5.4 */
 #define PNG_TRANSFORM_EXPAND_16     0x4000      /* read only */
-#if INT_MAX >= 0x8000 /* else this might break */
+#if ~0U > 0xffffU /* or else this might break on a 16-bit machine */
 #define PNG_TRANSFORM_SCALE_16      0x8000      /* read only */
 #endif
 
@@ -939,15 +907,15 @@ PNG_EXPORT(2, void, png_set_sig_bytes, (png_structrp png_ptr, int num_bytes));
 /* Check sig[start] through sig[start + num_to_check - 1] to see if it's a
  * PNG file.  Returns zero if the supplied bytes match the 8-byte PNG
  * signature, and non-zero otherwise.  Having num_to_check == 0 or
- * start > 7 will always fail (ie return non-zero).
+ * start > 7 will always fail (i.e. return non-zero).
  */
-PNG_EXPORT(3, int, png_sig_cmp, (png_const_bytep sig, png_size_t start,
-    png_size_t num_to_check));
+PNG_EXPORT(3, int, png_sig_cmp, (png_const_bytep sig, size_t start,
+    size_t num_to_check));
 
 /* Simple signature checking function.  This is the same as calling
- * png_check_sig(sig, n) := !png_sig_cmp(sig, 0, n).
+ * png_check_sig(sig, n) := (png_sig_cmp(sig, 0, n) == 0).
  */
-#define png_check_sig(sig, n) !png_sig_cmp((sig), 0, (n))
+#define png_check_sig(sig, n) (png_sig_cmp((sig), 0, (n)) == 0) /* DEPRECATED */
 
 /* Allocate and initialize png_ptr struct for reading, and any other memory. */
 PNG_EXPORTA(4, png_structp, png_create_read_struct,
@@ -961,11 +929,11 @@ PNG_EXPORTA(5, png_structp, png_create_write_struct,
     png_error_ptr warn_fn),
     PNG_ALLOCATED);
 
-PNG_EXPORT(6, png_size_t, png_get_compression_buffer_size,
+PNG_EXPORT(6, size_t, png_get_compression_buffer_size,
     (png_const_structrp png_ptr));
 
 PNG_EXPORT(7, void, png_set_compression_buffer_size, (png_structrp png_ptr,
-    png_size_t size));
+    size_t size));
 
 /* Moved from pngconf.h in 1.4.0 and modified to ensure setjmp/longjmp
  * match up.
@@ -1018,7 +986,7 @@ PNG_EXPORT(13, void, png_write_sig, (png_structrp png_ptr));
 
 /* Write a PNG chunk - size, type, (optional) data, CRC. */
 PNG_EXPORT(14, void, png_write_chunk, (png_structrp png_ptr, png_const_bytep
-    chunk_name, png_const_bytep data, png_size_t length));
+    chunk_name, png_const_bytep data, size_t length));
 
 /* Write the start of a PNG chunk - length and chunk name. */
 PNG_EXPORT(15, void, png_write_chunk_start, (png_structrp png_ptr,
@@ -1026,7 +994,7 @@ PNG_EXPORT(15, void, png_write_chunk_start, (png_structrp png_ptr,
 
 /* Write the data of a PNG chunk started with png_write_chunk_start(). */
 PNG_EXPORT(16, void, png_write_chunk_data, (png_structrp png_ptr,
-    png_const_bytep data, png_size_t length));
+    png_const_bytep data, size_t length));
 
 /* Finish a chunk started with png_write_chunk_start() (includes CRC). */
 PNG_EXPORT(17, void, png_write_chunk_end, (png_structrp png_ptr));
@@ -1040,7 +1008,7 @@ PNG_EXPORTA(18, png_infop, png_create_info_struct, (png_const_structrp png_ptr),
  * the API will be removed in the future.
  */
 PNG_EXPORTA(19, void, png_info_init_3, (png_infopp info_ptr,
-    png_size_t png_info_struct_size), PNG_DEPRECATED);
+    size_t png_info_struct_size), PNG_DEPRECATED);
 
 /* Writes all the PNG information before the image. */
 PNG_EXPORT(20, void, png_write_info_before_PLTE,
@@ -1137,7 +1105,7 @@ PNG_EXPORT(35, void, png_build_grayscale_palette, (int bit_depth,
  * corresponding composited pixel, and the color channels are unassociated
  * (not premultiplied).  The gamma encoded color channels must be scaled
  * according to the contribution and to do this it is necessary to undo
- * the encoding, scale the color values, perform the composition and reencode
+ * the encoding, scale the color values, perform the composition and re-encode
  * the values.  This is the 'PNG' mode.
  *
  * The alternative is to 'associate' the alpha with the color information by
@@ -1193,7 +1161,7 @@ PNG_FIXED_EXPORT(228, void, png_set_alpha_mode_fixed, (png_structrp png_ptr,
  *
  * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_GAMMA_MAC);
  *    In this case the output is assumed to be something like an sRGB conformant
- *    display preceeded by a power-law lookup table of power 1.45.  This is how
+ *    display preceded by a power-law lookup table of power 1.45.  This is how
  *    early Mac systems behaved.
  *
  * png_set_alpha_mode(pp, PNG_ALPHA_STANDARD, PNG_GAMMA_LINEAR);
@@ -1240,7 +1208,7 @@ PNG_FIXED_EXPORT(228, void, png_set_alpha_mode_fixed, (png_structrp png_ptr,
  *
  * When the default gamma of PNG files doesn't match the output gamma.
  *    If you have PNG files with no gamma information png_set_alpha_mode allows
- *    you to provide a default gamma, but it also sets the ouput gamma to the
+ *    you to provide a default gamma, but it also sets the output gamma to the
  *    matching value.  If you know your PNG files have a gamma that doesn't
  *    match the output you can take advantage of the fact that
  *    png_set_alpha_mode always sets the output gamma but only sets the PNG
@@ -1477,7 +1445,7 @@ PNG_EXPORT(66, void, png_set_crc_action, (png_structrp png_ptr, int crit_action,
  * mainly useful for testing, as the defaults should work with most users.
  * Those users who are tight on memory or want faster performance at the
  * expense of compression can modify them.  See the compression library
- * header file (zlib.h) for an explination of the compression functions.
+ * header file (zlib.h) for an explanation of the compression functions.
  */
 
 /* Set the filtering method(s) used by libpng.  Currently, the only valid
@@ -1532,7 +1500,7 @@ PNG_FIXED_EXPORT(209, void, png_set_filter_heuristics_fixed,
  * 0 - 9, corresponding directly to the zlib compression levels 0 - 9
  * (0 - no compression, 9 - "maximal" compression).  Note that tests have
  * shown that zlib compression levels 3-6 usually perform as well as level 9
- * for PNG images, and do considerably fewer caclulations.  In the future,
+ * for PNG images, and do considerably fewer calculations.  In the future,
  * these values may not correspond directly to the zlib compression levels.
  */
 #ifdef PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED
@@ -1691,7 +1659,7 @@ PNG_EXPORT(218, png_byte, png_get_current_pass_number, (png_const_structrp));
  *           chunk will cause an error at this point unless it is to be saved.
  * positive: The chunk was handled, libpng will ignore/discard it.
  *
- * See "INTERACTION WTIH USER CHUNK CALLBACKS" below for important notes about
+ * See "INTERACTION WITH USER CHUNK CALLBACKS" below for important notes about
  * how this behavior will change in libpng 1.7
  */
 PNG_EXPORT(88, void, png_set_read_user_chunk_fn, (png_structrp png_ptr,
@@ -1716,7 +1684,7 @@ PNG_EXPORT(91, png_voidp, png_get_progressive_ptr,
 
 /* Function to be called when data becomes available */
 PNG_EXPORT(92, void, png_process_data, (png_structrp png_ptr,
-    png_inforp info_ptr, png_bytep buffer, png_size_t buffer_size));
+    png_inforp info_ptr, png_bytep buffer, size_t buffer_size));
 
 /* A function which may be called *only* within png_process_data to stop the
  * processing of any more data.  The function returns the number of bytes
@@ -1725,7 +1693,7 @@ PNG_EXPORT(92, void, png_process_data, (png_structrp png_ptr,
  * 'save' is set to true the routine will first save all the pending data and
  * will always return 0.
  */
-PNG_EXPORT(219, png_size_t, png_process_data_pause, (png_structrp, int save));
+PNG_EXPORT(219, size_t, png_process_data_pause, (png_structrp, int save));
 
 /* A function which may be called *only* outside (after) a call to
  * png_process_data.  It returns the number of bytes of data to skip in the
@@ -1761,12 +1729,9 @@ PNG_EXPORT(97, void, png_free, (png_const_structrp png_ptr, png_voidp ptr));
 PNG_EXPORT(98, void, png_free_data, (png_const_structrp png_ptr,
     png_inforp info_ptr, png_uint_32 free_me, int num));
 
-/* Reassign responsibility for freeing existing data, whether allocated
+/* Reassign the responsibility for freeing existing data, whether allocated
  * by libpng or by the application; this works on the png_info structure passed
- * in, it does not change the state for other png_info structures.
- *
- * It is unlikely that this function works correctly as of 1.6.0 and using it
- * may result either in memory leaks or double free of allocated data.
+ * in, without changing the state for other png_info structures.
  */
 PNG_EXPORT(99, void, png_data_freer, (png_const_structrp png_ptr,
     png_inforp info_ptr, int freer, png_uint_32 mask));
@@ -1870,7 +1835,7 @@ PNG_EXPORT(110, png_uint_32, png_get_valid, (png_const_structrp png_ptr,
     png_const_inforp info_ptr, png_uint_32 flag));
 
 /* Returns number of bytes needed to hold a transformed row. */
-PNG_EXPORT(111, png_size_t, png_get_rowbytes, (png_const_structrp png_ptr,
+PNG_EXPORT(111, size_t, png_get_rowbytes, (png_const_structrp png_ptr,
     png_const_inforp info_ptr));
 
 #ifdef PNG_INFO_IMAGE_SUPPORTED
@@ -2013,12 +1978,12 @@ PNG_FIXED_EXPORT(233, void, png_set_cHRM_XYZ_fixed, (png_const_structrp png_ptr,
 PNG_EXPORT(246, png_uint_32, png_get_eXIf, (png_const_structrp png_ptr,
     png_inforp info_ptr, png_bytep *exif));
 PNG_EXPORT(247, void, png_set_eXIf, (png_const_structrp png_ptr,
-    png_inforp info_ptr, const png_bytep exif));
+    png_inforp info_ptr, png_bytep exif));
 
 PNG_EXPORT(248, png_uint_32, png_get_eXIf_1, (png_const_structrp png_ptr,
     png_const_inforp info_ptr, png_uint_32 *num_exif, png_bytep *exif));
 PNG_EXPORT(249, void, png_set_eXIf_1, (png_const_structrp png_ptr,
-    png_inforp info_ptr, const png_uint_32 num_exif, const png_bytep exif));
+    png_inforp info_ptr, png_uint_32 num_exif, png_bytep exif));
 #endif
 
 #ifdef PNG_gAMA_SUPPORTED
@@ -2239,7 +2204,7 @@ PNG_EXPORT(171, void, png_set_sCAL_s, (png_const_structrp png_ptr,
  * to specifying "NEVER", however when "AS_DEFAULT" is used for specific chunks
  * it simply resets the behavior to the libpng default.
  *
- * INTERACTION WTIH USER CHUNK CALLBACKS:
+ * INTERACTION WITH USER CHUNK CALLBACKS:
  * The per-chunk handling is always used when there is a png_user_chunk_ptr
  * callback and the callback returns 0; the chunk is then always stored *unless*
  * it is critical and the per-chunk setting is other than ALWAYS.  Notice that
@@ -2658,7 +2623,7 @@ PNG_EXPORT(243, int, png_get_palette_max, (png_const_structp png_ptr,
  * The simplified API hides the details of both libpng and the PNG file format
  * itself.  It allows PNG files to be read into a very limited number of
  * in-memory bitmap formats or to be written from the same formats.  If these
- * formats do not accomodate your needs then you can, and should, use the more
+ * formats do not accommodate your needs then you can, and should, use the more
  * sophisticated APIs above - these support a wide variety of in-memory formats
  * and a wide variety of sophisticated transformations to those formats as well
  * as a wide variety of APIs to manipulate ancillary information.
@@ -2764,7 +2729,7 @@ typedef struct
  *
  * When the simplified API needs to convert between sRGB and linear colorspaces,
  * the actual sRGB transfer curve defined in the sRGB specification (see the
- * article at https://en.wikipedia.org/wiki/SRGB) is used, not the gamma=1/2.2
+ * article at <https://en.wikipedia.org/wiki/SRGB>) is used, not the gamma=1/2.2
  * approximation used elsewhere in libpng.
  *
  * When an alpha channel is present it is expected to denote pixel coverage
@@ -2819,6 +2784,8 @@ typedef struct
 #  define PNG_FORMAT_FLAG_AFIRST 0x20U /* alpha channel comes first */
 #endif
 
+#define PNG_FORMAT_FLAG_ASSOCIATED_ALPHA 0x40U /* alpha channel is associated */
+
 /* Commonly used formats have predefined macros.
  *
  * First the single byte (sRGB) formats:
@@ -2965,7 +2932,7 @@ typedef struct
  * 'flags' field of png_image.
  */
 #define PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB 0x01
-   /* This indicates the the RGB values of the in-memory bitmap do not
+   /* This indicates that the RGB values of the in-memory bitmap do not
     * correspond to the red, green and blue end-points defined by sRGB.
     */
 
@@ -3018,7 +2985,7 @@ PNG_EXPORT(235, int, png_image_begin_read_from_stdio, (png_imagep image,
 #endif /* STDIO */
 
 PNG_EXPORT(236, int, png_image_begin_read_from_memory, (png_imagep image,
-   png_const_voidp memory, png_size_t size));
+   png_const_voidp memory, size_t size));
    /* The PNG header is read from the given memory buffer. */
 
 PNG_EXPORT(237, int, png_image_finish_read, (png_imagep image,
@@ -3131,7 +3098,7 @@ PNG_EXPORT(245, int, png_image_write_to_memory, (png_imagep image, void *memory,
     * than or equal to the original value.
     *
     * If the function returns false and *memory_bytes was not changed an error
-    * occured during write.  If *memory_bytes was changed, or is not 0 if
+    * occurred during write.  If *memory_bytes was changed, or is not 0 if
     * 'memory' was NULL, the write would have succeeded but for the memory
     * buffer being too small.  *memory_bytes contains the required number of
     * bytes and will be bigger that the original value.
@@ -3215,7 +3182,7 @@ PNG_EXPORT(245, int, png_image_write_to_memory, (png_imagep image, void *memory,
  * option and 'onoff' is 0 (off) or non-0 (on).  The value returned is given
  * by the PNG_OPTION_ defines below.
  *
- * HARDWARE: normally hardware capabilites, such as the Intel SSE instructions,
+ * HARDWARE: normally hardware capabilities, such as the Intel SSE instructions,
  *           are detected at run time, however sometimes it may be impossible
  *           to do this in user mode, in which case it is necessary to discover
  *           the capabilities in an OS specific way.  Such capabilities are
@@ -3236,11 +3203,18 @@ PNG_EXPORT(245, int, png_image_write_to_memory, (png_imagep image, void *memory,
 #ifdef PNG_MIPS_MSA_API_SUPPORTED
 #  define PNG_MIPS_MSA   6 /* HARDWARE: MIPS Msa SIMD instructions supported */
 #endif
-#define PNG_IGNORE_ADLER32 8
+#ifdef PNG_DISABLE_ADLER32_CHECK_SUPPORTED
+#  define PNG_IGNORE_ADLER32 8 /* SOFTWARE: disable Adler32 check on IDAT */
+#endif
 #ifdef PNG_POWERPC_VSX_API_SUPPORTED
-#  define PNG_POWERPC_VSX   10 /* HARDWARE: PowerPC VSX SIMD instructions supported */
+#  define PNG_POWERPC_VSX   10 /* HARDWARE: PowerPC VSX SIMD instructions
+                                * supported */
+#endif
+#ifdef PNG_MIPS_MMI_API_SUPPORTED
+#  define PNG_MIPS_MMI   12 /* HARDWARE: MIPS MMI SIMD instructions supported */
 #endif
-#define PNG_OPTION_NEXT  12 /* Next option - numbers must be even */
+
+#define PNG_OPTION_NEXT  14 /* Next option - numbers must be even */
 
 /* Return values: NOTE: there are four values and 'off' is *not* zero */
 #define PNG_OPTION_UNSET   0 /* Unset - defaults to off */
diff --git a/src/GLideNHQ/inc/pngconf.h b/src/GLideNHQ/inc/pngconf.h
index c0f1554..000d7b1 100644
--- a/src/GLideNHQ/inc/pngconf.h
+++ b/src/GLideNHQ/inc/pngconf.h
@@ -1,11 +1,12 @@
 
-/* pngconf.h - machine configurable file for libpng
+/* pngconf.h - machine-configurable file for libpng
  *
- * libpng version 1.6.32, August 24, 2017
+ * libpng version 1.6.43
  *
- * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ * Copyright (c) 2018-2024 Cosmin Truta
+ * Copyright (c) 1998-2002,2004,2006-2016,2018 Glenn Randers-Pehrson
+ * Copyright (c) 1996-1997 Andreas Dilger
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -57,14 +58,13 @@
 
 #endif /* PNG_BUILDING_SYMBOL_TABLE */
 
-/* Prior to 1.6.0 it was possible to turn off 'const' in declarations using
- * PNG_NO_CONST; this is no longer supported except for data declarations which
- * apparently still cause problems in 2011 on some compilers.
+/* Prior to 1.6.0, it was possible to turn off 'const' in declarations,
+ * using PNG_NO_CONST.  This is no longer supported.
  */
 #define PNG_CONST const /* backward compatibility only */
 
-/* This controls optimization of the reading of 16-bit and 32-bit values
- * from PNG files.  It can be set on a per-app-file basis - it
+/* This controls optimization of the reading of 16-bit and 32-bit
+ * values from PNG files.  It can be set on a per-app-file basis: it
  * just changes whether a macro is used when the function is called.
  * The library builder sets the default; if read functions are not
  * built into the library the macro implementation is forced on.
@@ -127,7 +127,7 @@
  *
  * These cases only differ if the operating system does not use the C
  * calling convention, at present this just means the above cases
- * (x86 DOS/Windows sytems) and, even then, this does not apply to
+ * (x86 DOS/Windows systems) and, even then, this does not apply to
  * Cygwin running on those systems.
  *
  * Note that the value must be defined in pnglibconf.h so that what
@@ -180,8 +180,8 @@
  * compiler-specific macros to the values required to change the calling
  * conventions of the various functions.
  */
-#if defined(_Windows) || defined(_WINDOWS) || defined(WIN32) ||\
-    defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+#if defined(_WIN32) || defined(__WIN32__) || defined(__NT__) || \
+    defined(__CYGWIN__)
   /* Windows system (DOS doesn't support DLLs).  Includes builds under Cygwin or
    * MinGW on any architecture currently supported by Windows.  Also includes
    * Watcom builds but these need special treatment because they are not
@@ -515,8 +515,10 @@
 #  error "libpng requires an unsigned 32-bit (or more) type"
 #endif
 
-/* Prior to 1.6.0 it was possible to disable the use of size_t, 1.6.0, however,
- * requires an ISOC90 compiler and relies on consistent behavior of sizeof.
+/* Prior to 1.6.0, it was possible to disable the use of size_t and ptrdiff_t.
+ * From 1.6.0 onwards, an ISO C90 compiler, as well as a standard-compliant
+ * behavior of sizeof and ptrdiff_t are required.
+ * The legacy typedefs are provided here for backwards compatibility.
  */
 typedef size_t png_size_t;
 typedef ptrdiff_t png_ptrdiff_t;
@@ -537,13 +539,12 @@ typedef ptrdiff_t png_ptrdiff_t;
 #  endif
 #endif
 
-/* png_alloc_size_t is guaranteed to be no smaller than png_size_t, and no
- * smaller than png_uint_32.  Casts from png_size_t or png_uint_32 to
- * png_alloc_size_t are not necessary; in fact, it is recommended not to use
- * them at all so that the compiler can complain when something turns out to be
- * problematic.
+/* png_alloc_size_t is guaranteed to be no smaller than size_t, and no smaller
+ * than png_uint_32.  Casts from size_t or png_uint_32 to png_alloc_size_t are
+ * not necessary; in fact, it is recommended not to use them at all, so that
+ * the compiler can complain when something turns out to be problematic.
  *
- * Casts in the other direction (from png_alloc_size_t to png_size_t or
+ * Casts in the other direction (from png_alloc_size_t to size_t or
  * png_uint_32) should be explicitly applied; however, we do not expect to
  * encounter practical situations that require such conversions.
  *
@@ -553,7 +554,7 @@ typedef ptrdiff_t png_ptrdiff_t;
 #ifdef PNG_SMALL_SIZE_T
    typedef png_uint_32 png_alloc_size_t;
 #else
-   typedef png_size_t png_alloc_size_t;
+   typedef size_t png_alloc_size_t;
 #endif
 
 /* Prior to 1.6.0 libpng offered limited support for Microsoft C compiler
@@ -589,8 +590,8 @@ typedef char                  * png_charp;
 typedef const char            * png_const_charp;
 typedef png_fixed_point       * png_fixed_point_p;
 typedef const png_fixed_point * png_const_fixed_point_p;
-typedef png_size_t            * png_size_tp;
-typedef const png_size_t      * png_const_size_tp;
+typedef size_t                * png_size_tp;
+typedef const size_t          * png_const_size_tp;
 
 #ifdef PNG_STDIO_SUPPORTED
 typedef FILE            * png_FILE_p;
diff --git a/src/GLideNHQ/inc/pnglibconf.h b/src/GLideNHQ/inc/pnglibconf.h
index 9e45f73..a81a642 100644
--- a/src/GLideNHQ/inc/pnglibconf.h
+++ b/src/GLideNHQ/inc/pnglibconf.h
@@ -1,10 +1,9 @@
-/* libpng 1.6.32 STANDARD API DEFINITION */
-
 /* pnglibconf.h - library build configuration */
 
-/* Libpng version 1.6.32 - August 24, 2017 */
+/* libpng version 1.6.43 */
 
-/* Copyright (c) 1998-2017 Glenn Randers-Pehrson */
+/* Copyright (c) 2018-2024 Cosmin Truta */
+/* Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson */
 
 /* This code is released under the libpng license. */
 /* For conditions of distribution and use, see the disclaimer */
@@ -20,8 +19,6 @@
 #define PNG_ALIGNED_MEMORY_SUPPORTED
 /*#undef PNG_ARM_NEON_API_SUPPORTED*/
 /*#undef PNG_ARM_NEON_CHECK_SUPPORTED*/
-/*#undef PNG_POWERPC_VSX_API_SUPPORTED*/
-/*#undef PNG_POWERPC_VSX_CHECK_SUPPORTED*/
 #define PNG_BENIGN_ERRORS_SUPPORTED
 #define PNG_BENIGN_READ_ERRORS_SUPPORTED
 /*#undef PNG_BENIGN_WRITE_ERRORS_SUPPORTED*/
@@ -30,6 +27,7 @@
 #define PNG_COLORSPACE_SUPPORTED
 #define PNG_CONSOLE_IO_SUPPORTED
 #define PNG_CONVERT_tIME_SUPPORTED
+/*#undef PNG_DISABLE_ADLER32_CHECK_SUPPORTED*/
 #define PNG_EASY_ACCESS_SUPPORTED
 /*#undef PNG_ERROR_NUMBERS_SUPPORTED*/
 #define PNG_ERROR_TEXT_SUPPORTED
@@ -44,8 +42,14 @@
 #define PNG_INCH_CONVERSIONS_SUPPORTED
 #define PNG_INFO_IMAGE_SUPPORTED
 #define PNG_IO_STATE_SUPPORTED
+/*#undef PNG_MIPS_MMI_API_SUPPORTED*/
+/*#undef PNG_MIPS_MMI_CHECK_SUPPORTED*/
+/*#undef PNG_MIPS_MSA_API_SUPPORTED*/
+/*#undef PNG_MIPS_MSA_CHECK_SUPPORTED*/
 #define PNG_MNG_FEATURES_SUPPORTED
 #define PNG_POINTER_INDEXING_SUPPORTED
+/*#undef PNG_POWERPC_VSX_API_SUPPORTED*/
+/*#undef PNG_POWERPC_VSX_CHECK_SUPPORTED*/
 #define PNG_PROGRESSIVE_READ_SUPPORTED
 #define PNG_READ_16BIT_SUPPORTED
 #define PNG_READ_ALPHA_MODE_SUPPORTED
@@ -210,7 +214,7 @@
 #define PNG_USER_HEIGHT_MAX 1000000
 #define PNG_USER_WIDTH_MAX 1000000
 #define PNG_ZBUF_SIZE 8192
-#define PNG_ZLIB_VERNUM 0 /* unknown */
+#define PNG_ZLIB_VERNUM 0x1280
 #define PNG_Z_DEFAULT_COMPRESSION (-1)
 #define PNG_Z_DEFAULT_NOFILTER_STRATEGY 0
 #define PNG_Z_DEFAULT_STRATEGY 1
diff --git a/src/GLideNHQ/lib/libpng.a b/src/GLideNHQ/lib/libpng.a
index bb5dec0..49f9c37 100644
Binary files a/src/GLideNHQ/lib/libpng.a and b/src/GLideNHQ/lib/libpng.a differ
diff --git a/src/GLideNHQ/lib/libz.a b/src/GLideNHQ/lib/libz.a
index 98a63cc..eb3e00c 100644
Binary files a/src/GLideNHQ/lib/libz.a and b/src/GLideNHQ/lib/libz.a differ
diff --git a/src/Graphics/OpenGLContext/GLFunctions.cpp b/src/Graphics/OpenGLContext/GLFunctions.cpp
index 1a6b8f6..80b1e86 100644
--- a/src/Graphics/OpenGLContext/GLFunctions.cpp
+++ b/src/Graphics/OpenGLContext/GLFunctions.cpp
@@ -14,7 +14,29 @@
 
 #elif defined(EGL)
 
-#define glGetProcAddress eglGetProcAddress
+#include <dlfcn.h>
+static void* _gles2_handle = nullptr;
+static void* _egl_handle = nullptr;
+static void* _dlsymGetProc(const char* name) {
+	if (!_gles2_handle) {
+		_gles2_handle = dlopen("libGLESv2.so.2", RTLD_LAZY | RTLD_NOLOAD);
+		if (!_gles2_handle)
+			_gles2_handle = dlopen("libGLESv2.so.2", RTLD_LAZY);
+	}
+	void* func = nullptr;
+	if (_gles2_handle) func = dlsym(_gles2_handle, name);
+	if (!func) {
+		if (!_egl_handle) {
+			_egl_handle = dlopen("libEGL.so.1", RTLD_LAZY | RTLD_NOLOAD);
+			if (!_egl_handle)
+				_egl_handle = dlopen("libEGL.so.1", RTLD_LAZY);
+		}
+		if (_egl_handle) func = dlsym(_egl_handle, name);
+	}
+	if (!func) func = dlsym(RTLD_DEFAULT, name);
+	return func;
+}
+#define glGetProcAddress _dlsymGetProc
 #define GL_GET_PROC_ADR(proc_type, proc_name) ptr##proc_name = (proc_type) glGetProcAddress("gl"#proc_name)
 #define GL_GET_PROC_ADR_EGL(proc_type, proc_name) ptr##proc_name = (proc_type) glGetProcAddress("egl"#proc_name)
 
diff --git a/src/Graphics/OpenGLContext/ThreadedOpenGl/opengl_Wrapper.cpp b/src/Graphics/OpenGLContext/ThreadedOpenGl/opengl_Wrapper.cpp
index 952c05e..55ba143 100644
--- a/src/Graphics/OpenGLContext/ThreadedOpenGl/opengl_Wrapper.cpp
+++ b/src/Graphics/OpenGLContext/ThreadedOpenGl/opengl_Wrapper.cpp
@@ -60,6 +60,14 @@ namespace opengl {
 #endif
 	}
 
+	void FunctionWrapper::executeOverlayCommand(std::shared_ptr<OpenGlCommand> _command)
+	{
+		if (m_threaded_wrapper)
+			executeCommand(_command);
+		else
+			_command->performCommandSingleThreaded();
+	}
+
 	void FunctionWrapper::commandLoop()
 	{
 		bool timeToShutdown = false;
diff --git a/src/Graphics/OpenGLContext/ThreadedOpenGl/opengl_Wrapper.h b/src/Graphics/OpenGLContext/ThreadedOpenGl/opengl_Wrapper.h
index 27210fa..6768543 100644
--- a/src/Graphics/OpenGLContext/ThreadedOpenGl/opengl_Wrapper.h
+++ b/src/Graphics/OpenGLContext/ThreadedOpenGl/opengl_Wrapper.h
@@ -57,6 +57,8 @@ namespace opengl {
 
 	public:
 		static void setThreadedMode(u32 _threaded);
+		static void executeOverlayCommand(std::shared_ptr<OpenGlCommand> _command);
+		static bool isThreadedMode() { return m_threaded_wrapper; }
 
 		static void wrBlendFunc(GLenum sfactor, GLenum dfactor);
 		static void wrBlendFuncSeparate(GLenum sfactorcolor, GLenum dfactorcolor, GLenum sfactoralpha, GLenum dfactoralpha);
diff --git a/src/Graphics/OpenGLContext/mupen64plus/mupen64plus_DisplayWindow.cpp b/src/Graphics/OpenGLContext/mupen64plus/mupen64plus_DisplayWindow.cpp
index 1573c83..03ab5c7 100644
--- a/src/Graphics/OpenGLContext/mupen64plus/mupen64plus_DisplayWindow.cpp
+++ b/src/Graphics/OpenGLContext/mupen64plus/mupen64plus_DisplayWindow.cpp
@@ -56,9 +56,15 @@ void DisplayWindowMupen64plus::_setAttributes()
 {
 	LOG(LOG_VERBOSE, "_setAttributes");
 
+#ifdef EGL
+	FunctionWrapper::CoreVideo_GL_SetAttribute(M64P_GL_CONTEXT_PROFILE_MASK, M64P_GL_CONTEXT_PROFILE_ES);
+	FunctionWrapper::CoreVideo_GL_SetAttribute(M64P_GL_CONTEXT_MAJOR_VERSION, 3);
+	FunctionWrapper::CoreVideo_GL_SetAttribute(M64P_GL_CONTEXT_MINOR_VERSION, 0);
+#else
 	FunctionWrapper::CoreVideo_GL_SetAttribute(M64P_GL_CONTEXT_PROFILE_MASK, M64P_GL_CONTEXT_PROFILE_CORE);
 	FunctionWrapper::CoreVideo_GL_SetAttribute(M64P_GL_CONTEXT_MAJOR_VERSION, 3);
 	FunctionWrapper::CoreVideo_GL_SetAttribute(M64P_GL_CONTEXT_MINOR_VERSION, 3);
+#endif
 
 	FunctionWrapper::CoreVideo_GL_SetAttribute(M64P_GL_DOUBLEBUFFER, 1);
 	FunctionWrapper::CoreVideo_GL_SetAttribute(M64P_GL_SWAP_CONTROL, config.video.verticalSync);
diff --git a/src/Graphics/OpenGLContext/opengl_GLInfo.cpp b/src/Graphics/OpenGLContext/opengl_GLInfo.cpp
index 3f9bc3e..e9b0c04 100644
--- a/src/Graphics/OpenGLContext/opengl_GLInfo.cpp
+++ b/src/Graphics/OpenGLContext/opengl_GLInfo.cpp
@@ -6,7 +6,8 @@
 #include <Graphics/Parameters.h>
 
 #ifdef EGL
-#include <EGL/egl.h>
+#include <dlfcn.h>
+#define eglGetProcAddress(name) dlsym(RTLD_DEFAULT, name)
 #endif
 
 #ifdef OS_ANDROID
@@ -173,6 +174,9 @@ void GLInfo::init() {
 	if (renderer == Renderer::PowerVR) {
 		config.frameBufferEmulation.forceDepthBufferClear = 1;
 		config.generalEmulation.enableFragmentDepthWrite = 0;
+		// Disable bufferStorage on PowerVR to avoid glBufferStorageEXT crash
+		// This forces UnbufferedDrawer with glBufferData fallback on GLES
+		bufferStorage = false;
 	}
 
 #ifdef OS_ANDROID
diff --git a/src/TextureFilterHandler.cpp b/src/TextureFilterHandler.cpp
index aa864df..86784c1 100644
--- a/src/TextureFilterHandler.cpp
+++ b/src/TextureFilterHandler.cpp
@@ -123,6 +123,8 @@ void TextureFilterHandler::init()
 		wRomName, // name of ROM. must be no longer than 256 characters
 		displayLoadProgress);
 
+	// Clear load progress display (signals loading is complete)
+	displayLoadProgress(L"");
 }
 
 void TextureFilterHandler::shutdown()
diff --git a/src/mupenplus/GLideN64_mupenplus.h b/src/mupenplus/GLideN64_mupenplus.h
index ba4bb16..1540543 100644
--- a/src/mupenplus/GLideN64_mupenplus.h
+++ b/src/mupenplus/GLideN64_mupenplus.h
@@ -52,6 +52,8 @@ extern ptr_VidExt_GL_GetAttribute       CoreVideo_GL_GetAttribute;
 extern ptr_VidExt_GL_SwapBuffers        CoreVideo_GL_SwapBuffers;
 extern ptr_VidExt_GL_GetDefaultFramebuffer CoreVideo_GL_GetDefaultFramebuffer;
 
+extern ptr_CoreDoCommand                CoreDoCommand;
+
 extern ptr_PluginGetVersion             CoreGetVersion;
 
 extern void*                            CoreDebugCallbackContext;
diff --git a/src/mupenplus/MupenPlusAPIImpl.cpp b/src/mupenplus/MupenPlusAPIImpl.cpp
index f059581..23e6e36 100644
--- a/src/mupenplus/MupenPlusAPIImpl.cpp
+++ b/src/mupenplus/MupenPlusAPIImpl.cpp
@@ -47,6 +47,8 @@ ptr_VidExt_GL_GetAttribute       CoreVideo_GL_GetAttribute = nullptr;
 ptr_VidExt_GL_SwapBuffers        CoreVideo_GL_SwapBuffers = nullptr;
 ptr_VidExt_GL_GetDefaultFramebuffer CoreVideo_GL_GetDefaultFramebuffer = nullptr;
 
+ptr_CoreDoCommand                CoreDoCommand = nullptr;
+
 ptr_PluginGetVersion             CoreGetVersion = nullptr;
 
 void*                            CoreDebugCallbackContext = nullptr;
@@ -100,6 +102,8 @@ m64p_error PluginAPI::PluginStartup(m64p_dynlib_handle _CoreLibHandle, void* Con
 
 	CoreGetVersion = (ptr_PluginGetVersion) DLSYM(_CoreLibHandle, "PluginGetVersion");
 
+	CoreDoCommand = (ptr_CoreDoCommand) DLSYM(_CoreLibHandle, "CoreDoCommand");
+
 #ifndef M64P_GLIDENUI
 	if (Config_SetDefault()) {
 		config.version = ConfigGetParamInt(g_configVideoGliden64, "configVersion");
diff --git a/SETTINGS.md b/SETTINGS.md
new file mode 100644
index 0000000..8279102
--- /dev/null
+++ b/SETTINGS.md
@@ -0,0 +1,220 @@
+# GLideN64 Standalone Plugin — Settings Reference
+
+Config file: `mupen64plus_sa/mupen64plus.cfg` → `[Video-GLideN64]` section
+
+---
+
+## Rendering
+
+| Setting | Values | Default | Description |
+|---------|--------|---------|-------------|
+| `UseNativeResolutionFactor` | 0-8 | 0 | Internal resolution multiplier. 0=window resolution, 1=320x240 (native), 2=640x480, 3=960x720, 4=1280x960, etc. |
+| `AspectRatio` | 0-4 | 1 | 0=stretch, 1=force 4:3, 2=force 16:9, 3=adjust 4:3, 4=adjust 16:9 |
+| `MultiSampling` | 0,2,4,8,16 | 0 | MSAA anti-aliasing. Higher = smoother edges, more GPU load |
+| `FXAA` | True/False | False | Fast Approximate Anti-Aliasing. Lighter than MSAA |
+| `anisotropy` | 0-16 | 0 | Anisotropic filtering for textures viewed at angles |
+| `bilinearMode` | 0/1 | 1 | 0=N64 3-point filtering (authentic), 1=standard bilinear |
+| `enableHalosRemoval` | True/False | False | Remove halos around filtered textures |
+| `EnableHybridFilter` | True/False | True | Hybrid integer scaling filter. **Can be slow on embedded GPUs** |
+| `EnableHWLighting` | True/False | False | Per-pixel hardware lighting. More accurate, heavier |
+| `EnableCoverage` | True/False | False | Pixel coverage calculation. Better blending, needs fast GPU |
+| `EnableClipping` | True/False | True | Software vertex clipping. Recommended on |
+| `ThreadedVideo` | True/False | False | Threaded video backend. **May break input on embedded** |
+| `BufferSwapMode` | 0-2 | 0 | 0=On VI update, 1=On VI origin change, 2=On buffer update |
+
+## Sprite / Texrect Fix (black lines between 2D elements)
+
+These settings fix visible lines/gaps between 2D sprites and UI elements:
+
+| Setting | Values | Default | Description |
+|---------|--------|---------|-------------|
+| `CorrectTexrectCoords` | 0-2 | 0 | **Fix black lines between 2D texrects.** 0=Off, 1=Auto, 2=Force. Try `1` or `2` if you see lines |
+| `EnableNativeResTexrects` | 0-2 | 0 | Render 2D texrects in native resolution to fix misalignment. 0=Off, 1=Optimized, 2=Unoptimized |
+| `EnableTexCoordBounds` | 0/1 | 0 | Bound texture coordinates to native values. Prevents garbage at texture edges but can cause hard edges |
+
+**If you see horizontal/vertical lines between sprites**, set:
+```
+CorrectTexrectCoords = 2
+EnableNativeResTexrects = 1
+```
+
+## Dithering
+
+| Setting | Values | Default | Description |
+|---------|--------|---------|-------------|
+| `EnableDitheringPattern` | True/False | False | Dithering pattern on output image |
+| `EnableHiresNoiseDithering` | True/False | False | Hi-res noise dithering |
+| `DitheringQuantization` | True/False | True | Color quantization dithering |
+| `RDRAMImageDitheringMode` | 0-3 | 3 | 0=disable, 1=bayer, 2=magic square, 3=blue noise |
+
+## Hi-Res Texture Packs
+
+| Setting | Values | Default | Description |
+|---------|--------|---------|-------------|
+| `txHiresEnable` | True/False | False | **Master switch for hi-res texture packs** |
+| `txPath` | path | `./data/hires_texture` | Folder containing texture pack subfolders (named by ROM internal name) |
+| `txHiresTextureFileStorage` | True/False | False | **Load textures from files on demand (no RAM cache). Best for embedded devices** |
+| `txHiresFullAlphaChannel` | True/False | True | Full alpha channel for hi-res textures |
+| `txHresAltCRC` | True/False | False | Alternative CRC calculation for paletted textures |
+| `txHiresVramLimit` | MB | 0 | VRAM limit for hi-res textures. 0=unlimited |
+| `txNoTextureFileStorage` | True/False | False | Disable all file storage/cache for HD textures |
+| `txForce16bpp` | True/False | False | Force 16-bit textures (saves VRAM, lower quality) |
+
+## Texture Enhancement (upscales native N64 textures)
+
+| Setting | Values | Default | Description |
+|---------|--------|---------|-------------|
+| `txFilterMode` | 0-6 | 0 | 0=none, 1-4=smooth filtering (1=lightest, 4=heaviest), 5-6=sharp filtering |
+| `txEnhancementMode` | 0-13 | 0 | 0=none, 1=store as is, 2=X2, 3=X2SAI, 4=HQ2X, 5=HQ2XS, 6=LQ2X, 7=LQ2XS, 8=HQ4X, 9=2xBRZ, 10=3xBRZ, 11=4xBRZ, 12=5xBRZ, 13=6xBRZ |
+| `txDeposterize` | True/False | False | Deposterize before enhancement |
+| `txFilterIgnoreBG` | True/False | False | Don't filter background textures |
+| `txEnhancedTextureFileStorage` | True/False | False | File storage for enhanced textures |
+
+## Texture Cache
+
+| Setting | Values | Default | Description |
+|---------|--------|---------|-------------|
+| `txCacheSize` | MB | 100 | Memory cache size for enhanced textures |
+| `txCacheCompression` | True/False | True | Compress texture cache |
+| `txSaveCache` | True/False | True | Save texture cache to disk |
+| `txCachePath` | path | `./cache/cache` | Cache file location |
+| `txDump` | True/False | False | Dump textures (for texture pack creation) |
+| `txDumpPath` | path | `./cache/texture_dump` | Dump output location |
+| `txStrongCRC` | True/False | False | Strong CRC for texture dump |
+
+## Frame Buffer Emulation
+
+| Setting | Values | Default | Description |
+|---------|--------|---------|-------------|
+| `EnableFBEmulation` | True/False | True | Master switch for frame buffer emulation. Required for many effects |
+| `EnableCopyColorToRDRAM` | 0-3 | 2 | 0=don't copy, 1=sync, 2=double buffer, 3=triple buffer |
+| `EnableCopyDepthToRDRAM` | 0-2 | 2 | 0=don't copy, 1=from video memory, 2=software render |
+| `EnableCopyColorFromRDRAM` | True/False | False | Copy color buffer from RDRAM |
+| `EnableCopyAuxiliaryToRDRAM` | True/False | False | Copy auxiliary buffers to RDRAM |
+| `EnableN64DepthCompare` | 0-2 | 0 | 0=off, 1=fast, 2=compatible. Experimental |
+| `ForceDepthBufferClear` | True/False | False | Hack for Eikou no Saint Andrews |
+| `DisableFBInfo` | True/False | True | Disable FBInfo read/write. Use for problem games |
+| `FBInfoReadColorChunk` | True/False | False | Read color buffer in 4KB chunks |
+| `FBInfoReadDepthChunk` | True/False | True | Read depth buffer in 4KB chunks |
+
+## Overscan
+
+| Setting | Values | Default | Description |
+|---------|--------|---------|-------------|
+| `EnableOverscan` | True/False | False | Crop output by overscan bounds |
+| `OverscanNtscLeft/Right/Top/Bottom` | pixels | 0 | NTSC crop bounds |
+| `OverscanPalLeft/Right/Top/Bottom` | pixels | 0 | PAL crop bounds |
+
+## Performance (Embedded / Low-End GPU)
+
+| Setting | Values | Default | Description |
+|---------|--------|---------|-------------|
+| `EnableInaccurateTextureCoordinates` | True/False | False | **Faster shaders, less accurate** |
+| `EnableLegacyBlending` | True/False | False | **Skip shader-based blending. Faster but may glitch** |
+| `EnableShadersStorage` | True/False | True | Cache compiled shaders to disk. Faster startup after first run |
+| `EnableFragmentDepthWrite` | True/False | True | Some mobile GPUs need this off |
+| `EnableHybridFilter` | True/False | True | **Disable for better performance on slow GPUs** |
+| `BackgroundsMode` | 0/1 | 1 | 0=One piece (fast), 1=Stripped (precise) |
+
+## Display / OSD
+
+| Setting | Values | Default | Description |
+|---------|--------|---------|-------------|
+| `ShowFPS` | True/False | False | Show FPS counter |
+| `ShowVIS` | True/False | False | Show VI/s counter |
+| `ShowPercent` | True/False | False | Show speed percentage |
+| `ShowInternalResolution` | True/False | False | Show internal resolution |
+| `ShowRenderingResolution` | True/False | False | Show rendering resolution |
+| `ShowStatistics` | True/False | False | Show draw call statistics |
+| `CountersPos` | bitmask | 8 | 1=top-left, 2=top-center, 4=top-right, 8=bottom-left, 16=bottom-center, 32=bottom-right |
+| `fontName` | filename | FreeSans.ttf | OSD font file |
+| `fontSize` | pixels | 18 | OSD font size |
+| `fontColor` | RGB hex | B5E61D | OSD font color |
+
+## Gamma
+
+| Setting | Values | Default | Description |
+|---------|--------|---------|-------------|
+| `ForceGammaCorrection` | True/False | False | Force gamma correction |
+| `GammaCorrectionLevel` | float | 2.0 | Gamma level |
+
+## Recommended Settings for TG5050 / TG5040
+
+These are the optimized defaults based on testing on both devices.
+Both devices support GLES 3.2 (TG5040: PowerVR GE8300, TG5050: Mali-G57).
+
+```ini
+[Video-GLideN64]
+
+# === Rendering ===
+UseNativeResolutionFactor = 2    # 640x480 upscaled (good balance of quality/performance)
+AspectRatio = 1                  # Force 4:3
+bilinearMode = 1                 # Standard bilinear filtering
+FXAA = False                     # Disabled — saves GPU
+MultiSampling = 0                # No MSAA — saves GPU
+anisotropy = 2                   # Light anisotropic filtering
+EnableHybridFilter = False       # Disabled — slow on embedded GPUs
+EnableHWLighting = False         # Disabled — saves GPU
+EnableCoverage = False           # Disabled — needs fast GPU
+EnableClipping = True            # Software vertex clipping — recommended on
+ThreadedVideo = False            # Disabled — can break input on embedded
+BufferSwapMode = 0               # On VI update (default)
+
+# === Sprite / Texrect Fix ===
+CorrectTexrectCoords = 2         # Force — fixes black lines between 2D sprites
+EnableNativeResTexrects = 1      # Optimized — fixes 2D element misalignment
+EnableTexCoordBounds = 0         # Off — can cause hard edges if enabled
+
+# === Dithering ===
+EnableDitheringPattern = False   # Off
+DitheringQuantization = True     # Color quantization dithering
+RDRAMImageDitheringMode = 3      # Blue noise (best quality)
+EnableHiresNoiseDithering = False
+
+# === Hi-Res Texture Packs ===
+txHiresEnable = True             # Enable hi-res texture loading
+txHiresTextureFileStorage = True # Lazy load from files (no RAM cache — critical for embedded)
+txHiresFullAlphaChannel = True   # Full alpha channel support
+txHresAltCRC = False             # Standard CRC calculation
+txPath = "/mnt/SDCARD/Roms/Nintendo 64 (N64)/.hires_texture"
+txCacheSize = 100                # 100MB cache size
+txCacheCompression = True        # Compress cache
+txSaveCache = True               # Save cache to disk
+
+# === Texture Enhancement ===
+txFilterMode = 0                 # None (no extra filtering)
+txEnhancementMode = 0            # None (no upscaling of native textures)
+txDeposterize = False
+txFilterIgnoreBG = False
+
+# === Frame Buffer Emulation ===
+EnableFBEmulation = True         # Required for many visual effects
+EnableCopyColorToRDRAM = 2       # Double buffer (good balance)
+EnableCopyDepthToRDRAM = 2       # Software render (most compatible)
+EnableCopyColorFromRDRAM = False
+EnableCopyAuxiliaryToRDRAM = False
+EnableN64DepthCompare = 0        # Off (experimental feature)
+ForceDepthBufferClear = False
+DisableFBInfo = True             # Disabled for compatibility
+
+# === Performance ===
+EnableInaccurateTextureCoordinates = False  # Keep accurate
+EnableLegacyBlending = False     # Keep shader-based blending
+EnableShadersStorage = True      # Cache shaders — faster startup after first run
+EnableFragmentDepthWrite = True  # Required by some GPUs
+BackgroundsMode = 0             # One piece (faster)
+
+# === Gamma ===
+ForceGammaCorrection = False
+GammaCorrectionLevel = 2.0
+```
+
+### TG5040-specific notes
+- Same GPU capability (GLES 3.2) but weaker CPU (Cortex-A53 vs A55)
+- Consider `UseNativeResolutionFactor = 1` (native 320x240) if performance is tight
+- Screen is smaller so lower resolution is less noticeable
+
+### TG5050-specific notes
+- Stronger CPU with big cluster (Cortex-A55 @ 2160 MHz)
+- `UseNativeResolutionFactor = 2` (640x480) works well
+- Can try `anisotropy = 4` or `UseNativeResolutionFactor = 3` on less demanding games
diff --git a/toolchain-aarch64.cmake b/toolchain-aarch64.cmake
new file mode 100644
index 0000000..3d79fd8
--- /dev/null
+++ b/toolchain-aarch64.cmake
@@ -0,0 +1,37 @@
+set(CMAKE_SYSTEM_NAME Linux)
+set(CMAKE_SYSTEM_PROCESSOR aarch64)
+
+set(TOOLCHAIN_ROOT /opt/aarch64-nextui-linux-gnu)
+set(SYSROOT ${TOOLCHAIN_ROOT}/aarch64-nextui-linux-gnu/sysroot)
+set(LIBC_ROOT ${TOOLCHAIN_ROOT}/aarch64-nextui-linux-gnu/libc)
+
+set(CMAKE_C_COMPILER ${TOOLCHAIN_ROOT}/bin/aarch64-nextui-linux-gnu-gcc)
+set(CMAKE_CXX_COMPILER ${TOOLCHAIN_ROOT}/bin/aarch64-nextui-linux-gnu-g++)
+
+set(CMAKE_FIND_ROOT_PATH ${SYSROOT} ${LIBC_ROOT}/usr)
+set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
+set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
+set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
+
+# GLES/EGL headers from workspace
+include_directories(/root/workspace/all/include)
+
+# aarch64 libpng and zlib from toolchain libc
+include_directories(${LIBC_ROOT}/usr/include)
+link_directories(${LIBC_ROOT}/usr/lib)
+
+# Set PNG/ZLIB paths for find_package
+set(PNG_LIBRARY ${LIBC_ROOT}/usr/lib/libpng.a)
+set(PNG_PNG_INCLUDE_DIR ${LIBC_ROOT}/usr/include)
+set(ZLIB_LIBRARY ${LIBC_ROOT}/usr/lib/libz.so)
+set(ZLIB_INCLUDE_DIR ${LIBC_ROOT}/usr/include)
+
+# Freetype2 for OSD text rendering
+set(FREETYPE_INCLUDE_DIRS ${LIBC_ROOT}/usr/include/freetype2)
+set(FREETYPE_LIBRARIES ${LIBC_ROOT}/usr/lib/libfreetype.a ${LIBC_ROOT}/usr/lib/libbz2.a)
+set(FREETYPE_FOUND TRUE)
+
+# SDL_ttf and SDL_image for overlay menu fonts and button icons
+set(SDL_TTF_INCLUDE_DIRS ${LIBC_ROOT}/usr/include/SDL2)
+set(SDL_TTF_LIBRARIES ${LIBC_ROOT}/usr/lib/libSDL2_ttf.so)
+set(SDL_IMAGE_LIBRARIES ${LIBC_ROOT}/usr/lib/libSDL2_image.so)
diff --git a/src/overlay/OverlayGL.cpp b/src/overlay/OverlayGL.cpp
new file mode 100644
index 0000000..8da4772
--- /dev/null
+++ b/src/overlay/OverlayGL.cpp
@@ -0,0 +1,650 @@
+#include "OverlayGL.h"
+
+#include <GLES3/gl3.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdint.h>
+
+// ---------------------------------------------------------------------------
+// Embedded 8x8 bitmap font (ASCII 32-126, public domain font8x8_basic)
+// Each character: 8 rows, 1 byte per row, bit 0 = leftmost pixel
+// ---------------------------------------------------------------------------
+
+static const unsigned char s_font8x8[95][8] = {
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // 32 (space)
+	{0x18,0x3C,0x3C,0x18,0x18,0x00,0x18,0x00}, // 33 !
+	{0x36,0x36,0x00,0x00,0x00,0x00,0x00,0x00}, // 34 "
+	{0x36,0x36,0x7F,0x36,0x7F,0x36,0x36,0x00}, // 35 #
+	{0x0C,0x3E,0x03,0x1E,0x30,0x1F,0x0C,0x00}, // 36 $
+	{0x00,0x63,0x33,0x18,0x0C,0x66,0x63,0x00}, // 37 %
+	{0x1C,0x36,0x1C,0x6E,0x3B,0x33,0x6E,0x00}, // 38 &
+	{0x06,0x06,0x03,0x00,0x00,0x00,0x00,0x00}, // 39 '
+	{0x18,0x0C,0x06,0x06,0x06,0x0C,0x18,0x00}, // 40 (
+	{0x06,0x0C,0x18,0x18,0x18,0x0C,0x06,0x00}, // 41 )
+	{0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00}, // 42 *
+	{0x00,0x0C,0x0C,0x3F,0x0C,0x0C,0x00,0x00}, // 43 +
+	{0x00,0x00,0x00,0x00,0x00,0x0C,0x0C,0x06}, // 44 ,
+	{0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00}, // 45 -
+	{0x00,0x00,0x00,0x00,0x00,0x0C,0x0C,0x00}, // 46 .
+	{0x60,0x30,0x18,0x0C,0x06,0x03,0x01,0x00}, // 47 /
+	{0x3E,0x63,0x73,0x7B,0x6F,0x67,0x3E,0x00}, // 48 0
+	{0x0C,0x0E,0x0C,0x0C,0x0C,0x0C,0x3F,0x00}, // 49 1
+	{0x1E,0x33,0x30,0x1C,0x06,0x33,0x3F,0x00}, // 50 2
+	{0x1E,0x33,0x30,0x1C,0x30,0x33,0x1E,0x00}, // 51 3
+	{0x38,0x3C,0x36,0x33,0x7F,0x30,0x78,0x00}, // 52 4
+	{0x3F,0x03,0x1F,0x30,0x30,0x33,0x1E,0x00}, // 53 5
+	{0x1C,0x06,0x03,0x1F,0x33,0x33,0x1E,0x00}, // 54 6
+	{0x3F,0x33,0x30,0x18,0x0C,0x0C,0x0C,0x00}, // 55 7
+	{0x1E,0x33,0x33,0x1E,0x33,0x33,0x1E,0x00}, // 56 8
+	{0x1E,0x33,0x33,0x3E,0x30,0x18,0x0E,0x00}, // 57 9
+	{0x00,0x0C,0x0C,0x00,0x00,0x0C,0x0C,0x00}, // 58 :
+	{0x00,0x0C,0x0C,0x00,0x00,0x0C,0x0C,0x06}, // 59 ;
+	{0x18,0x0C,0x06,0x03,0x06,0x0C,0x18,0x00}, // 60 <
+	{0x00,0x00,0x3F,0x00,0x00,0x3F,0x00,0x00}, // 61 =
+	{0x06,0x0C,0x18,0x30,0x18,0x0C,0x06,0x00}, // 62 >
+	{0x1E,0x33,0x30,0x18,0x0C,0x00,0x0C,0x00}, // 63 ?
+	{0x3E,0x63,0x7B,0x7B,0x7B,0x03,0x1E,0x00}, // 64 @
+	{0x0C,0x1E,0x33,0x33,0x3F,0x33,0x33,0x00}, // 65 A
+	{0x3F,0x66,0x66,0x3E,0x66,0x66,0x3F,0x00}, // 66 B
+	{0x3C,0x66,0x03,0x03,0x03,0x66,0x3C,0x00}, // 67 C
+	{0x1F,0x36,0x66,0x66,0x66,0x36,0x1F,0x00}, // 68 D
+	{0x7F,0x46,0x16,0x1E,0x16,0x46,0x7F,0x00}, // 69 E
+	{0x7F,0x46,0x16,0x1E,0x16,0x06,0x0F,0x00}, // 70 F
+	{0x3C,0x66,0x03,0x03,0x73,0x66,0x7C,0x00}, // 71 G
+	{0x33,0x33,0x33,0x3F,0x33,0x33,0x33,0x00}, // 72 H
+	{0x1E,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00}, // 73 I
+	{0x78,0x30,0x30,0x30,0x33,0x33,0x1E,0x00}, // 74 J
+	{0x67,0x66,0x36,0x1E,0x36,0x66,0x67,0x00}, // 75 K
+	{0x0F,0x06,0x06,0x06,0x46,0x66,0x7F,0x00}, // 76 L
+	{0x63,0x77,0x7F,0x7F,0x6B,0x63,0x63,0x00}, // 77 M
+	{0x63,0x67,0x6F,0x7B,0x73,0x63,0x63,0x00}, // 78 N
+	{0x1C,0x36,0x63,0x63,0x63,0x36,0x1C,0x00}, // 79 O
+	{0x3F,0x66,0x66,0x3E,0x06,0x06,0x0F,0x00}, // 80 P
+	{0x1E,0x33,0x33,0x33,0x3B,0x1E,0x38,0x00}, // 81 Q
+	{0x3F,0x66,0x66,0x3E,0x36,0x66,0x67,0x00}, // 82 R
+	{0x1E,0x33,0x07,0x0E,0x38,0x33,0x1E,0x00}, // 83 S
+	{0x3F,0x2D,0x0C,0x0C,0x0C,0x0C,0x1E,0x00}, // 84 T
+	{0x33,0x33,0x33,0x33,0x33,0x33,0x3F,0x00}, // 85 U
+	{0x33,0x33,0x33,0x33,0x33,0x1E,0x0C,0x00}, // 86 V
+	{0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00}, // 87 W
+	{0x63,0x63,0x36,0x1C,0x1C,0x36,0x63,0x00}, // 88 X
+	{0x33,0x33,0x33,0x1E,0x0C,0x0C,0x1E,0x00}, // 89 Y
+	{0x7F,0x63,0x31,0x18,0x4C,0x66,0x7F,0x00}, // 90 Z
+	{0x1E,0x06,0x06,0x06,0x06,0x06,0x1E,0x00}, // 91 [
+	{0x03,0x06,0x0C,0x18,0x30,0x60,0x40,0x00}, // 92 backslash
+	{0x1E,0x18,0x18,0x18,0x18,0x18,0x1E,0x00}, // 93 ]
+	{0x08,0x1C,0x36,0x63,0x00,0x00,0x00,0x00}, // 94 ^
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF}, // 95 _
+	{0x0C,0x0C,0x18,0x00,0x00,0x00,0x00,0x00}, // 96 `
+	{0x00,0x00,0x1E,0x30,0x3E,0x33,0x6E,0x00}, // 97 a
+	{0x07,0x06,0x06,0x3E,0x66,0x66,0x3B,0x00}, // 98 b
+	{0x00,0x00,0x1E,0x33,0x03,0x33,0x1E,0x00}, // 99 c
+	{0x38,0x30,0x30,0x3E,0x33,0x33,0x6E,0x00}, // 100 d
+	{0x00,0x00,0x1E,0x33,0x3F,0x03,0x1E,0x00}, // 101 e
+	{0x1C,0x36,0x06,0x0F,0x06,0x06,0x0F,0x00}, // 102 f
+	{0x00,0x00,0x6E,0x33,0x33,0x3E,0x30,0x1F}, // 103 g
+	{0x07,0x06,0x36,0x6E,0x66,0x66,0x67,0x00}, // 104 h
+	{0x0C,0x00,0x0E,0x0C,0x0C,0x0C,0x1E,0x00}, // 105 i
+	{0x30,0x00,0x30,0x30,0x30,0x33,0x33,0x1E}, // 106 j
+	{0x07,0x06,0x66,0x36,0x1E,0x36,0x67,0x00}, // 107 k
+	{0x0E,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00}, // 108 l
+	{0x00,0x00,0x33,0x7F,0x7F,0x6B,0x63,0x00}, // 109 m
+	{0x00,0x00,0x1F,0x33,0x33,0x33,0x33,0x00}, // 110 n
+	{0x00,0x00,0x1E,0x33,0x33,0x33,0x1E,0x00}, // 111 o
+	{0x00,0x00,0x3B,0x66,0x66,0x3E,0x06,0x0F}, // 112 p
+	{0x00,0x00,0x6E,0x33,0x33,0x3E,0x30,0x78}, // 113 q
+	{0x00,0x00,0x3B,0x6E,0x66,0x06,0x0F,0x00}, // 114 r
+	{0x00,0x00,0x3E,0x03,0x1E,0x30,0x1F,0x00}, // 115 s
+	{0x08,0x0C,0x3E,0x0C,0x0C,0x2C,0x18,0x00}, // 116 t
+	{0x00,0x00,0x33,0x33,0x33,0x33,0x6E,0x00}, // 117 u
+	{0x00,0x00,0x33,0x33,0x33,0x1E,0x0C,0x00}, // 118 v
+	{0x00,0x00,0x63,0x6B,0x7F,0x7F,0x36,0x00}, // 119 w
+	{0x00,0x00,0x63,0x36,0x1C,0x36,0x63,0x00}, // 120 x
+	{0x00,0x00,0x33,0x33,0x33,0x3E,0x30,0x1F}, // 121 y
+	{0x00,0x00,0x3F,0x19,0x0C,0x26,0x3F,0x00}, // 122 z
+	{0x38,0x0C,0x0C,0x07,0x0C,0x0C,0x38,0x00}, // 123 {
+	{0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00}, // 124 |
+	{0x07,0x0C,0x0C,0x38,0x0C,0x0C,0x07,0x00}, // 125 }
+	{0x6E,0x3B,0x00,0x00,0x00,0x00,0x00,0x00}, // 126 ~
+};
+
+// Font rendering scale per font_id: LARGE=0, SMALL=1, TINY=2
+static const int s_fontScale[3] = { 3, 2, 1 };
+
+// ---------------------------------------------------------------------------
+// Shader sources
+// ---------------------------------------------------------------------------
+
+static const char* s_solidVS =
+	"#version 300 es\n"
+	"in vec2 aPos;\n"
+	"void main() {\n"
+	"    gl_Position = vec4(aPos, 0.0, 1.0);\n"
+	"}\n";
+
+static const char* s_solidFS =
+	"#version 300 es\n"
+	"precision mediump float;\n"
+	"uniform vec4 uColor;\n"
+	"out vec4 fragColor;\n"
+	"void main() {\n"
+	"    fragColor = uColor;\n"
+	"}\n";
+
+static const char* s_texVS =
+	"#version 300 es\n"
+	"in vec2 aPos;\n"
+	"in vec2 aTexCoord;\n"
+	"out vec2 vTexCoord;\n"
+	"void main() {\n"
+	"    gl_Position = vec4(aPos, 0.0, 1.0);\n"
+	"    vTexCoord = aTexCoord;\n"
+	"}\n";
+
+static const char* s_texFS =
+	"#version 300 es\n"
+	"precision mediump float;\n"
+	"in vec2 vTexCoord;\n"
+	"uniform sampler2D uTexture;\n"
+	"uniform float uDim;\n"
+	"out vec4 fragColor;\n"
+	"void main() {\n"
+	"    vec4 c = texture(uTexture, vTexCoord);\n"
+	"    fragColor = vec4(c.rgb * uDim, c.a);\n"
+	"}\n";
+
+// Text shader: samples font atlas alpha, applies uniform color
+static const char* s_textFS =
+	"#version 300 es\n"
+	"precision mediump float;\n"
+	"in vec2 vTexCoord;\n"
+	"uniform sampler2D uTexture;\n"
+	"uniform vec4 uColor;\n"
+	"out vec4 fragColor;\n"
+	"void main() {\n"
+	"    float a = texture(uTexture, vTexCoord).r;\n"
+	"    fragColor = vec4(uColor.rgb, uColor.a * a);\n"
+	"}\n";
+
+// ---------------------------------------------------------------------------
+// State
+// ---------------------------------------------------------------------------
+
+static GLuint s_solidProgram = 0;
+static GLint  s_solidLocColor = -1;
+
+static GLuint s_texProgram = 0;
+static GLint  s_texLocTexture = -1;
+static GLint  s_texLocDim = -1;
+
+static GLuint s_textProgram = 0;
+static GLint  s_textLocTexture = -1;
+static GLint  s_textLocColor = -1;
+
+static GLuint s_captureTexture = 0;
+static GLuint s_fontTexture = 0;
+static GLuint s_solidVAO = 0;
+static GLuint s_solidVBO = 0;
+static GLuint s_texVAO = 0;
+static GLuint s_texVBO = 0;
+
+static int s_screenW = 0;
+static int s_screenH = 0;
+
+// Font atlas layout: 16 chars per row, 6 rows (96 cells for 95 chars + 1 blank)
+#define FONT_ATLAS_COLS  16
+#define FONT_ATLAS_ROWS  6
+#define FONT_ATLAS_W     (FONT_ATLAS_COLS * 8)  // 128
+#define FONT_ATLAS_H     (FONT_ATLAS_ROWS * 8)  // 48
+
+// Saved GL state for begin_frame / end_frame
+static GLint   s_savedViewport[4];
+static GLint   s_savedScissorBox[4];
+static GLboolean s_savedBlend;
+static GLboolean s_savedDepthTest;
+static GLboolean s_savedCullFace;
+static GLboolean s_savedScissorTest;
+static GLint   s_savedBlendSrcRGB;
+static GLint   s_savedBlendDstRGB;
+static GLint   s_savedBlendSrcAlpha;
+static GLint   s_savedBlendDstAlpha;
+static GLint   s_savedProgram;
+static GLint   s_savedVAO;
+static GLint   s_savedVBO;
+static GLint   s_savedTex0;
+static GLint   s_savedActiveTexUnit;
+
+// ---------------------------------------------------------------------------
+// Helpers
+// ---------------------------------------------------------------------------
+
+static GLuint compile_shader(GLenum type, const char* src)
+{
+	GLuint sh = glCreateShader(type);
+	if (sh == 0) {
+		fprintf(stderr, "[OverlayGL] glCreateShader failed, glError=%d\n", glGetError());
+		return 0;
+	}
+	glShaderSource(sh, 1, &src, nullptr);
+	glCompileShader(sh);
+
+	GLint ok = 0;
+	glGetShaderiv(sh, GL_COMPILE_STATUS, &ok);
+	if (!ok) {
+		char log[512];
+		log[0] = '\0';
+		GLsizei logLen = 0;
+		glGetShaderInfoLog(sh, sizeof(log) - 1, &logLen, log);
+		log[logLen] = '\0';
+		fprintf(stderr, "[OverlayGL] shader compile error (type=%s, len=%d): %s\n",
+			type == GL_VERTEX_SHADER ? "VS" : "FS", logLen, log);
+		glDeleteShader(sh);
+		return 0;
+	}
+	return sh;
+}
+
+static GLuint link_program(GLuint vs, GLuint fs)
+{
+	GLuint prog = glCreateProgram();
+	glAttachShader(prog, vs);
+	glAttachShader(prog, fs);
+	glLinkProgram(prog);
+
+	GLint ok = 0;
+	glGetProgramiv(prog, GL_LINK_STATUS, &ok);
+	if (!ok) {
+		char log[512];
+		glGetProgramInfoLog(prog, sizeof(log), nullptr, log);
+		fprintf(stderr, "[OverlayGL] program link error: %s\n", log);
+		glDeleteProgram(prog);
+		return 0;
+	}
+	return prog;
+}
+
+static inline float ndc_x(float px)
+{
+	return 2.0f * px / (float)s_screenW - 1.0f;
+}
+
+static inline float ndc_y(float py)
+{
+	return 1.0f - 2.0f * py / (float)s_screenH;
+}
+
+static void build_font_texture(void)
+{
+	unsigned char pixels[FONT_ATLAS_W * FONT_ATLAS_H];
+	memset(pixels, 0, sizeof(pixels));
+
+	for (int c = 0; c < 95; c++) {
+		int col = c % FONT_ATLAS_COLS;
+		int row = c / FONT_ATLAS_COLS;
+		for (int y = 0; y < 8; y++) {
+			unsigned char bits = s_font8x8[c][y];
+			for (int x = 0; x < 8; x++) {
+				if (bits & (1 << x))
+					pixels[(row * 8 + y) * FONT_ATLAS_W + col * 8 + x] = 255;
+			}
+		}
+	}
+
+	glGenTextures(1, &s_fontTexture);
+	glBindTexture(GL_TEXTURE_2D, s_fontTexture);
+	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+	glTexImage2D(GL_TEXTURE_2D, 0, GL_R8, FONT_ATLAS_W, FONT_ATLAS_H, 0,
+	             GL_RED, GL_UNSIGNED_BYTE, pixels);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+	glBindTexture(GL_TEXTURE_2D, 0);
+}
+
+// ---------------------------------------------------------------------------
+// Backend functions
+// ---------------------------------------------------------------------------
+
+static int ovl_gl_init(int screen_w, int screen_h)
+{
+	s_screenW = screen_w;
+	s_screenH = screen_h;
+
+	// Save GL state — overlay init runs on the video thread in threaded mode,
+	// and raw gl* calls bypass GLideN64's cached state tracking. We must restore
+	// all state we modify to prevent stale cache issues (black screen on PowerVR).
+	GLint savedVAO = 0, savedVBO = 0, savedTex = 0, savedUnpackAlign = 4;
+	glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &savedVAO);
+	glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &savedVBO);
+	glGetIntegerv(GL_TEXTURE_BINDING_2D, &savedTex);
+	glGetIntegerv(GL_UNPACK_ALIGNMENT, &savedUnpackAlign);
+
+	// Build solid color program
+	{
+		GLuint vs = compile_shader(GL_VERTEX_SHADER, s_solidVS);
+		GLuint fs = compile_shader(GL_FRAGMENT_SHADER, s_solidFS);
+		if (!vs || !fs) return -1;
+		s_solidProgram = link_program(vs, fs);
+		glDeleteShader(vs);
+		glDeleteShader(fs);
+		if (!s_solidProgram) return -1;
+		s_solidLocColor = glGetUniformLocation(s_solidProgram, "uColor");
+	}
+
+	// Build textured (dim) program — for captured frame
+	{
+		GLuint vs = compile_shader(GL_VERTEX_SHADER, s_texVS);
+		GLuint fs = compile_shader(GL_FRAGMENT_SHADER, s_texFS);
+		if (!vs || !fs) return -1;
+		s_texProgram = link_program(vs, fs);
+		glDeleteShader(vs);
+		glDeleteShader(fs);
+		if (!s_texProgram) return -1;
+		s_texLocTexture = glGetUniformLocation(s_texProgram, "uTexture");
+		s_texLocDim = glGetUniformLocation(s_texProgram, "uDim");
+	}
+
+	// Build text shader program — for bitmap font rendering
+	{
+		GLuint vs = compile_shader(GL_VERTEX_SHADER, s_texVS); // reuse tex vertex shader
+		GLuint fs = compile_shader(GL_FRAGMENT_SHADER, s_textFS);
+		if (!vs || !fs) return -1;
+		s_textProgram = link_program(vs, fs);
+		glDeleteShader(vs);
+		glDeleteShader(fs);
+		if (!s_textProgram) return -1;
+		s_textLocTexture = glGetUniformLocation(s_textProgram, "uTexture");
+		s_textLocColor = glGetUniformLocation(s_textProgram, "uColor");
+	}
+
+	// VAO/VBO for solid quads (6 verts * 2 floats, dynamic)
+	glGenVertexArrays(1, &s_solidVAO);
+	glGenBuffers(1, &s_solidVBO);
+	glBindVertexArray(s_solidVAO);
+	glBindBuffer(GL_ARRAY_BUFFER, s_solidVBO);
+	glBufferData(GL_ARRAY_BUFFER, 6 * 2 * sizeof(float), nullptr, GL_DYNAMIC_DRAW);
+	GLint solidPosLoc = glGetAttribLocation(s_solidProgram, "aPos");
+	glEnableVertexAttribArray(solidPosLoc);
+	glVertexAttribPointer(solidPosLoc, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0);
+	glBindVertexArray(0);
+
+	// VAO/VBO for textured quads (6 verts * 4 floats: pos.xy + uv.xy)
+	glGenVertexArrays(1, &s_texVAO);
+	glGenBuffers(1, &s_texVBO);
+	glBindVertexArray(s_texVAO);
+	glBindBuffer(GL_ARRAY_BUFFER, s_texVBO);
+	// Allocate enough for text batching: max 128 chars * 6 verts * 4 floats
+	glBufferData(GL_ARRAY_BUFFER, 128 * 6 * 4 * sizeof(float), nullptr, GL_DYNAMIC_DRAW);
+	GLint texPosLoc = glGetAttribLocation(s_texProgram, "aPos");
+	GLint texUVLoc  = glGetAttribLocation(s_texProgram, "aTexCoord");
+	glEnableVertexAttribArray(texPosLoc);
+	glVertexAttribPointer(texPosLoc, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0);
+	glEnableVertexAttribArray(texUVLoc);
+	glVertexAttribPointer(texUVLoc, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)(2 * sizeof(float)));
+	glBindVertexArray(0);
+
+	// Capture texture (allocated on first capture)
+	glGenTextures(1, &s_captureTexture);
+	glBindTexture(GL_TEXTURE_2D, s_captureTexture);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+	glBindTexture(GL_TEXTURE_2D, 0);
+
+	// Build bitmap font atlas texture
+	build_font_texture();
+
+	// Restore GL state to avoid corrupting GLideN64's cached state
+	glBindVertexArray(savedVAO);
+	glBindBuffer(GL_ARRAY_BUFFER, savedVBO);
+	glBindTexture(GL_TEXTURE_2D, savedTex);
+	glPixelStorei(GL_UNPACK_ALIGNMENT, savedUnpackAlign);
+
+	return 0;
+}
+
+static void ovl_gl_destroy(void)
+{
+	if (s_solidProgram) { glDeleteProgram(s_solidProgram); s_solidProgram = 0; }
+	if (s_texProgram)   { glDeleteProgram(s_texProgram);   s_texProgram = 0; }
+	if (s_textProgram)  { glDeleteProgram(s_textProgram);  s_textProgram = 0; }
+	if (s_solidVAO)     { glDeleteVertexArrays(1, &s_solidVAO); s_solidVAO = 0; }
+	if (s_solidVBO)     { glDeleteBuffers(1, &s_solidVBO);      s_solidVBO = 0; }
+	if (s_texVAO)       { glDeleteVertexArrays(1, &s_texVAO);   s_texVAO = 0; }
+	if (s_texVBO)       { glDeleteBuffers(1, &s_texVBO);         s_texVBO = 0; }
+	if (s_captureTexture) { glDeleteTextures(1, &s_captureTexture); s_captureTexture = 0; }
+	if (s_fontTexture)    { glDeleteTextures(1, &s_fontTexture);    s_fontTexture = 0; }
+}
+
+static void ovl_gl_begin_frame(void)
+{
+	// Save GL state (must restore ALL state overlay touches to avoid
+	// corrupting GLideN64's CachedFunctions state — especially on PowerVR)
+	glGetIntegerv(GL_VIEWPORT, s_savedViewport);
+	glGetIntegerv(GL_SCISSOR_BOX, s_savedScissorBox);
+	s_savedBlend      = glIsEnabled(GL_BLEND);
+	s_savedDepthTest  = glIsEnabled(GL_DEPTH_TEST);
+	s_savedCullFace   = glIsEnabled(GL_CULL_FACE);
+	s_savedScissorTest = glIsEnabled(GL_SCISSOR_TEST);
+	glGetIntegerv(GL_BLEND_SRC_RGB,   &s_savedBlendSrcRGB);
+	glGetIntegerv(GL_BLEND_DST_RGB,   &s_savedBlendDstRGB);
+	glGetIntegerv(GL_BLEND_SRC_ALPHA, &s_savedBlendSrcAlpha);
+	glGetIntegerv(GL_BLEND_DST_ALPHA, &s_savedBlendDstAlpha);
+	glGetIntegerv(GL_CURRENT_PROGRAM, &s_savedProgram);
+	glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &s_savedVAO);
+	glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &s_savedVBO);
+	glGetIntegerv(GL_ACTIVE_TEXTURE, &s_savedActiveTexUnit);
+	glActiveTexture(GL_TEXTURE0);
+	glGetIntegerv(GL_TEXTURE_BINDING_2D, &s_savedTex0);
+
+	// Set overlay state
+	glViewport(0, 0, s_screenW, s_screenH);
+	glDisable(GL_DEPTH_TEST);
+	glDisable(GL_CULL_FACE);
+	glDisable(GL_SCISSOR_TEST);
+	glEnable(GL_BLEND);
+	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+}
+
+static void ovl_gl_end_frame(void)
+{
+	// Restore GL state
+	glViewport(s_savedViewport[0], s_savedViewport[1],
+	           s_savedViewport[2], s_savedViewport[3]);
+	glScissor(s_savedScissorBox[0], s_savedScissorBox[1],
+	          s_savedScissorBox[2], s_savedScissorBox[3]);
+
+	if (s_savedBlend)       glEnable(GL_BLEND);       else glDisable(GL_BLEND);
+	if (s_savedDepthTest)   glEnable(GL_DEPTH_TEST);   else glDisable(GL_DEPTH_TEST);
+	if (s_savedCullFace)    glEnable(GL_CULL_FACE);    else glDisable(GL_CULL_FACE);
+	if (s_savedScissorTest) glEnable(GL_SCISSOR_TEST); else glDisable(GL_SCISSOR_TEST);
+
+	glBlendFuncSeparate(s_savedBlendSrcRGB, s_savedBlendDstRGB,
+	                    s_savedBlendSrcAlpha, s_savedBlendDstAlpha);
+
+	// Restore object bindings (critical for GLideN64's cached state on PowerVR)
+	glUseProgram(s_savedProgram);
+	glBindVertexArray(s_savedVAO);
+	glBindBuffer(GL_ARRAY_BUFFER, s_savedVBO);
+	glActiveTexture(GL_TEXTURE0);
+	glBindTexture(GL_TEXTURE_2D, s_savedTex0);
+	glActiveTexture(s_savedActiveTexUnit);
+}
+
+static void ovl_gl_capture_frame(void)
+{
+	glBindTexture(GL_TEXTURE_2D, s_captureTexture);
+	glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 0, 0, s_screenW, s_screenH, 0);
+	glBindTexture(GL_TEXTURE_2D, 0);
+}
+
+static void ovl_gl_draw_captured_frame(float dim)
+{
+	// Fullscreen textured quad
+	float verts[] = {
+		// pos.x, pos.y, u, v  (note: framebuffer is bottom-up so flip V)
+		-1.0f, -1.0f,  0.0f, 0.0f,
+		 1.0f, -1.0f,  1.0f, 0.0f,
+		-1.0f,  1.0f,  0.0f, 1.0f,
+		 1.0f, -1.0f,  1.0f, 0.0f,
+		 1.0f,  1.0f,  1.0f, 1.0f,
+		-1.0f,  1.0f,  0.0f, 1.0f,
+	};
+
+	glUseProgram(s_texProgram);
+	glActiveTexture(GL_TEXTURE0);
+	glBindTexture(GL_TEXTURE_2D, s_captureTexture);
+	glUniform1i(s_texLocTexture, 0);
+	glUniform1f(s_texLocDim, dim);
+
+	glBindVertexArray(s_texVAO);
+	glBindBuffer(GL_ARRAY_BUFFER, s_texVBO);
+	glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(verts), verts);
+	glDrawArrays(GL_TRIANGLES, 0, 6);
+	glBindVertexArray(0);
+	glBindTexture(GL_TEXTURE_2D, 0);
+	glUseProgram(0);
+}
+
+static void ovl_gl_draw_rect(int x, int y, int w, int h, uint32_t color)
+{
+	float x0 = ndc_x((float)x);
+	float y0 = ndc_y((float)y);
+	float x1 = ndc_x((float)(x + w));
+	float y1 = ndc_y((float)(y + h));
+
+	float verts[] = {
+		x0, y1,
+		x1, y1,
+		x0, y0,
+		x1, y1,
+		x1, y0,
+		x0, y0,
+	};
+
+	// Extract ARGB
+	float a = (float)((color >> 24) & 0xFF) / 255.0f;
+	float r = (float)((color >> 16) & 0xFF) / 255.0f;
+	float g = (float)((color >>  8) & 0xFF) / 255.0f;
+	float b = (float)((color      ) & 0xFF) / 255.0f;
+
+	glUseProgram(s_solidProgram);
+	glUniform4f(s_solidLocColor, r, g, b, a);
+
+	glBindVertexArray(s_solidVAO);
+	glBindBuffer(GL_ARRAY_BUFFER, s_solidVBO);
+	glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(verts), verts);
+	glDrawArrays(GL_TRIANGLES, 0, 6);
+	glBindVertexArray(0);
+	glUseProgram(0);
+}
+
+static void ovl_gl_draw_text(const char* text, int x, int y, uint32_t color, int font_id)
+{
+	if (!text || !*text) return;
+
+	int scale = (font_id >= 0 && font_id <= 2) ? s_fontScale[font_id] : 2;
+	int charW = 8 * scale;
+	int charH = 8 * scale;
+
+	// UV size per character in atlas
+	float uChar = 8.0f / (float)FONT_ATLAS_W;
+	float vChar = 8.0f / (float)FONT_ATLAS_H;
+
+	// Extract ARGB
+	float a = (float)((color >> 24) & 0xFF) / 255.0f;
+	float r = (float)((color >> 16) & 0xFF) / 255.0f;
+	float g = (float)((color >>  8) & 0xFF) / 255.0f;
+	float b = (float)((color      ) & 0xFF) / 255.0f;
+
+	// Build vertex data for all characters (batched)
+	int len = 0;
+	for (const char* p = text; *p; p++) len++;
+	if (len > 128) len = 128;
+
+	float verts[128 * 6 * 4]; // max 128 chars, 6 verts each, 4 floats per vert
+	int vi = 0;
+	int cx = x;
+
+	for (int i = 0; i < len; i++) {
+		unsigned char ch = (unsigned char)text[i];
+		if (ch < 32 || ch > 126) ch = '?';
+		int idx = ch - 32;
+
+		int col = idx % FONT_ATLAS_COLS;
+		int row = idx / FONT_ATLAS_COLS;
+		float u0 = (float)(col * 8) / (float)FONT_ATLAS_W;
+		float v0 = (float)(row * 8) / (float)FONT_ATLAS_H;
+		float u1 = u0 + uChar;
+		float v1 = v0 + vChar;
+
+		float px0 = ndc_x((float)cx);
+		float py0 = ndc_y((float)y);
+		float px1 = ndc_x((float)(cx + charW));
+		float py1 = ndc_y((float)(y + charH));
+
+		// Triangle 1: top-left, top-right, bottom-left
+		verts[vi++] = px0; verts[vi++] = py0; verts[vi++] = u0; verts[vi++] = v0;
+		verts[vi++] = px1; verts[vi++] = py0; verts[vi++] = u1; verts[vi++] = v0;
+		verts[vi++] = px0; verts[vi++] = py1; verts[vi++] = u0; verts[vi++] = v1;
+		// Triangle 2: top-right, bottom-right, bottom-left
+		verts[vi++] = px1; verts[vi++] = py0; verts[vi++] = u1; verts[vi++] = v0;
+		verts[vi++] = px1; verts[vi++] = py1; verts[vi++] = u1; verts[vi++] = v1;
+		verts[vi++] = px0; verts[vi++] = py1; verts[vi++] = u0; verts[vi++] = v1;
+
+		cx += charW;
+	}
+
+	glUseProgram(s_textProgram);
+	glActiveTexture(GL_TEXTURE0);
+	glBindTexture(GL_TEXTURE_2D, s_fontTexture);
+	glUniform1i(s_textLocTexture, 0);
+	glUniform4f(s_textLocColor, r, g, b, a);
+
+	glBindVertexArray(s_texVAO);
+	glBindBuffer(GL_ARRAY_BUFFER, s_texVBO);
+	glBufferSubData(GL_ARRAY_BUFFER, 0, (GLsizeiptr)(vi * sizeof(float)), verts);
+	glDrawArrays(GL_TRIANGLES, 0, len * 6);
+	glBindVertexArray(0);
+	glBindTexture(GL_TEXTURE_2D, 0);
+	glUseProgram(0);
+}
+
+static int ovl_gl_text_width(const char* text, int font_id)
+{
+	if (!text) return 0;
+	int scale = (font_id >= 0 && font_id <= 2) ? s_fontScale[font_id] : 2;
+	int len = 0;
+	for (const char* p = text; *p; p++) len++;
+	return len * 8 * scale;
+}
+
+static int ovl_gl_text_height(int font_id)
+{
+	int scale = (font_id >= 0 && font_id <= 2) ? s_fontScale[font_id] : 2;
+	return 8 * scale;
+}
+
+// ---------------------------------------------------------------------------
+// Backend struct
+// ---------------------------------------------------------------------------
+
+static EmuOvlRenderBackend s_backend = {
+	ovl_gl_init,
+	ovl_gl_destroy,
+	ovl_gl_draw_rect,
+	ovl_gl_draw_text,
+	ovl_gl_text_width,
+	ovl_gl_text_height,
+	ovl_gl_begin_frame,
+	ovl_gl_end_frame,
+	ovl_gl_capture_frame,
+	ovl_gl_draw_captured_frame
+};
+
+EmuOvlRenderBackend* overlay_gl_get_backend(void)
+{
+	return &s_backend;
+}
diff --git a/src/overlay/OverlayGL.h b/src/overlay/OverlayGL.h
new file mode 100644
index 0000000..51cc6da
--- /dev/null
+++ b/src/overlay/OverlayGL.h
@@ -0,0 +1,16 @@
+#ifndef OVERLAY_GL_H
+#define OVERLAY_GL_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "emu_overlay_render.h"
+
+EmuOvlRenderBackend* overlay_gl_get_backend(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
