--- src/video/drastic_video.c.orig
+++ src/video/drastic_video.c
@@ -48,6 +48,7 @@
 #ifdef ADVDRASTIC_DRM
 #include <fcntl.h>
 #include <unistd.h>
+#include <poll.h>
 #include <xf86drm.h>
 #include <xf86drmMode.h>
 #include <gbm.h>
@@ -159,6 +160,19 @@
 #define BLUE 0X0000FF
 
 struct drm_device drm_buf;
+
+static int pflip_pending = 0;
+
+static void page_flip_handler(int fd, unsigned int sequence,
+    unsigned int tv_sec, unsigned int tv_usec, void *user_data)
+{
+    pflip_pending = 0;
+}
+
+static drmEventContext drm_evctx = {
+    .version = 2,
+    .page_flip_handler = page_flip_handler,
+};
 #endif
 
 // Declaration of thread condition variable
@@ -345,6 +359,14 @@
 [trngaje] cc=11, x=180, y=368, Return to game
 [trngaje] cc=12, x=180, y=384, Exit DraStic
 */
+
+// Check if a menu item text should be hidden
+static int is_hidden_menu_item(const char *msg)
+{
+    if (!memcmp(msg, "Load new game", 13)) return 1;
+    return 0;
+}
+
 static int draw_drastic_menu_main(void)
 {
     int cc = 0;
@@ -377,20 +399,20 @@
         
         //printf("[trngaje] cc=%d, x=%d, y=%d, %s\n", cc, p->x, p->y, drastic_menu.item[cc].msg);
         if (p->y == 201) {
+            // Version header — draw above menu items with gap
             draw = 1;
-
-            sprintf(buf, "Advanced NDS");
-
-            x = g_advdrastic.iDisplay_width - get_font_width(buf) - 10;
-            //y = 10 / div;
-            //y = 10;
-            y = g_advdrastic.iDisplay_height * 10 / 480;
+            sprintf(buf, "DraStic %s", p->msg);
+            x = g_advdrastic.iDisplay_width * 90 / 640;
+            y = h - w * 2;
         }
         else if (p->x == 180) {
+            // Hide unwanted menu items
+            if (is_hidden_menu_item(p->msg)) continue;
+
             draw = 1;
             y = h + ((menu_line_cnt) * w);
             menu_line_cnt++;
-            strcpy(buf, to_lang(drastic_menu.item[cc].msg));             
+            strcpy(buf, to_lang(drastic_menu.item[cc].msg));
         }
         else if (p->x ==  544) {
             draw = 1;
@@ -444,15 +466,7 @@
         }
     }
 
-    //y = 10;
-    y = g_advdrastic.iDisplay_height * 10 / 480;
-
-    //sprintf(buf, "Rel "NDS_VER);
-    sprintf(buf, "Advanced Drastic");
-    
-    //draw_info(nds.menu.drastic.main, buf, 10, y / div, nds.menu.c1, 0);
-    //draw_info(nds.menu.drastic.main, buf, 10, y, nds.menu.c1, 0);
-    draw_info(nds.menu.drastic.main, buf, g_advdrastic.iDisplay_width * 10 / 640, y, nds.menu.c1, 0);
+    // (removed "DraStic v1.9" label — version shown above menu items instead)
 
     if (draw_shot) {
         const uint32_t len = NDS_W * NDS_H * 2;
@@ -1137,14 +1151,15 @@
     //                    0xff, 0xff, 0xff));
     SDL_FillRect(nds.menu.drastic.main, &rt, SDL_MapRGB(nds.menu.drastic.main->format,
                         0, 0, 0));
- /*                       
+
     if (layer == NDS_DRASTIC_MENU_MAIN) {
-        SDL_SoftStretch(nds.menu.drastic.bg0, NULL, nds.menu.drastic.main, NULL);
+        if (nds.menu.drastic.bg0)
+            SDL_SoftStretch(nds.menu.drastic.bg0, NULL, nds.menu.drastic.main, NULL);
     }
     else {
-        SDL_SoftStretch(nds.menu.drastic.bg1, NULL, nds.menu.drastic.main, NULL);
+        if (nds.menu.drastic.bg1)
+            SDL_SoftStretch(nds.menu.drastic.bg1, NULL, nds.menu.drastic.main, NULL);
     }
-*/
     switch (layer) {
     case NDS_DRASTIC_MENU_MAIN:
         draw_drastic_menu_main();
@@ -1353,12 +1368,8 @@
             srt.w = NDS_Wx2;
             srt.h = NDS_Hx2;
             nds.screen.pitch[idx] = nds.screen.bpp * srt.w;
-            if (nds.hres_mode == 0) {
-                nds.pen.pos = 0;
-                nds.hres_mode = 1;
-                pre_dis_mode = g_advdrastic.ucLayoutIndex[nds.hres_mode];
-                nds.dis_mode = pre_hres_mode;
-            }
+            // Don't switch hres_mode — use normal layouts for all modes
+            // Hi-res pixel data gets scaled to fit the layout rect
         }
         else {
             srt.w = NDS_W;
@@ -1366,12 +1377,6 @@
             nds.screen.pitch[idx] = nds.screen.bpp * srt.w;
 
             drt.y = idx * 120;
-
-            if (nds.hres_mode == 1) {
-                nds.hres_mode = 0;
-                pre_hres_mode = g_advdrastic.ucLayoutIndex[nds.hres_mode];
-                nds.dis_mode = pre_dis_mode;
-            }
         }
 
         usLayoutRotate = getlayout_rotate(nds.hres_mode, g_advdrastic.ucLayoutIndex[nds.hres_mode]);
@@ -1483,9 +1488,7 @@
             }
         }
 
-        if (nds.screen.hres_mode[idx]) {
-            break;
-        }
+        // Don't break on hires — render both screens for all layouts
     }
 
     if (show_info_cnt > 0) {
@@ -1556,11 +1559,74 @@
     g_advdrastic.ucLayoutIndex[nds.hres_mode]= ( g_advdrastic.ucLayoutIndex[nds.hres_mode] + 1) % getmax_layout(nds.hres_mode);
 }
 
-void sdl_get_gui_input(long param_1,unsigned int *param_2)
+// Check if the cursor is currently on a hidden menu item (bg > 0 = selected)
+static int cursor_on_hidden_item(void)
 {
-    printf("[trngaje] sdl_get_gui_input:param_1=%p\n", param_1 - base_addr_rx);
+    int cc;
+    for (cc = 0; cc < drastic_menu.cnt; cc++) {
+        if (drastic_menu.item[cc].bg > 0 && drastic_menu.item[cc].x == 180) {
+            if (is_hidden_menu_item(drastic_menu.item[cc].msg))
+                return 1;
+        }
+    }
+    return 0;
 }
 
+static int gui_last_direction = DRASTIC_GUI_INPUT_DOWN;
+
+void sdl_get_gui_input(long param_1, unsigned int *param_2)
+{
+    SDL_Event event;
+
+    // Auto-skip hidden menu items — inject direction to move past them
+    if (cursor_on_hidden_item()) {
+        param_2[0] = gui_last_direction;
+        param_2[1] = 0;
+        return;
+    }
+
+    param_2[0] = 0xb;  // frame update (no button input)
+    param_2[1] = 0;
+
+    while (SDL_PollEvent(&event)) {
+        switch (event.type) {
+        case SDL_JOYHATMOTION:
+            if (event.jhat.value & SDL_HAT_UP) {
+                param_2[0] = DRASTIC_GUI_INPUT_UP;
+                gui_last_direction = DRASTIC_GUI_INPUT_UP;
+                return;
+            }
+            if (event.jhat.value & SDL_HAT_DOWN) {
+                param_2[0] = DRASTIC_GUI_INPUT_DOWN;
+                gui_last_direction = DRASTIC_GUI_INPUT_DOWN;
+                return;
+            }
+            if (event.jhat.value & SDL_HAT_LEFT) {
+                param_2[0] = DRASTIC_GUI_INPUT_LEFT;
+                return;
+            }
+            if (event.jhat.value & SDL_HAT_RIGHT) {
+                param_2[0] = DRASTIC_GUI_INPUT_RIGHT;
+                return;
+            }
+            break;
+
+        case SDL_JOYBUTTONDOWN:
+            switch (event.jbutton.button) {
+            case 0:  // B button
+                param_2[0] = DRASTIC_GUI_INPUT_B;
+                return;
+            case 1:  // A button
+                param_2[0] = DRASTIC_GUI_INPUT_A;
+                return;
+            }
+            break;
+        }
+    }
+
+    usleep(16000);  // ~60fps frame pacing when idle
+}
+
 void display_custom_setting(void)
 {
     unsigned int input_value[2];
@@ -2508,56 +2574,40 @@
         }
     }
 
-    // add by trngaje
-/*
-        if  (g_advdrastic.ulInput != 0) {
-            // 0x20000000000, 42
-            //printf("[trngaje] %p \n", 1L << (0x29 + ADVANCE_CONTROL_INDEX_ASSIGN_HOT)); 
-
-            
-            //if (g_advdrastic.ulInput  & 0x20000000000) {
-            //    printf("[trngaje] sdl_update_input(else): hot key pressed\n");
-            //}
-            printf("[trngaje] sdl_update_input(else): %p\n", g_advdrastic.ulInput);
-        }
-*/
+    // debug hotkey combos
+    if (g_advdrastic.ulInput != 0) {
+        printf(PREFIX"ulInput=0x%lx HOT=%d LDEC=%d LINC=%d THEME=%d backup=0x%lx\n",
+            g_advdrastic.ulInput,
+            !!(g_advdrastic.ulInput & (1L << (0x29 + ADVANCE_CONTROL_INDEX_ASSIGN_HOT))),
+            !!(g_advdrastic.ulInput & (1L << (0x29 + ADVANCE_CONTROL_INDEX_CHANGE_LAYOUT_DEC))),
+            !!(g_advdrastic.ulInput & (1L << (0x29 + ADVANCE_CONTROL_INDEX_CHANGE_LAYOUT_INC))),
+            !!(g_advdrastic.ulInput & (1L << (0x29 + ADVANCE_CONTROL_INDEX_HOT_CHANGE_THEME))),
+            backup_input);
+    }
+
     //if (uVar9 & 0x800) { // hotkey : select
-    if (g_advdrastic.ulInput & (1L << (0x29 + ADVANCE_CONTROL_INDEX_ASSIGN_HOT))) { 
+    if (g_advdrastic.ulInput & (1L << (0x29 + ADVANCE_CONTROL_INDEX_ASSIGN_HOT))) {
         if (g_advdrastic.ulInput != backup_input) {
             if (g_advdrastic.ulInput & (1L << (0x29 + ADVANCE_CONTROL_INDEX_CHANGE_LAYOUT_DEC))) {
-                if (g_advdrastic.ucLayoutIndex[nds.hres_mode] > 0) {
-                    g_advdrastic.ucLayoutIndex[nds.hres_mode] -= 1;
+                // Always cycle normal layouts (hres_mode=0) since that's where user layouts are
+                printf(PREFIX"HOTKEY: LAYOUT_DEC idx=%d->", g_advdrastic.ucLayoutIndex[0]);
+                if (g_advdrastic.ucLayoutIndex[0] > 0) {
+                    g_advdrastic.ucLayoutIndex[0] -= 1;
                 }
-/*
-                if (nds.hres_mode == 0) {
-                    if (nds.dis_mode > 0) {
-                        nds.dis_mode -= 1;
-                    }
-                }
-                else {
-                    nds.dis_mode = NDS_DIS_MODE_HRES0;
-                }
-*/
+                printf("%d max=%d\n", g_advdrastic.ucLayoutIndex[0], getmax_layout(0));
+                need_reload_bg = RELOAD_BG_COUNT;
                 backup_input = g_advdrastic.ulInput;
-                goto LAB_000986b4;	
-            } 
+                goto LAB_000986b4;
+            }
             else if (g_advdrastic.ulInput & (1L << (0x29 + ADVANCE_CONTROL_INDEX_CHANGE_LAYOUT_INC))) {
-                if (g_advdrastic.ucLayoutIndex[nds.hres_mode] < (getmax_layout(nds.hres_mode)-1)) {
-                    g_advdrastic.ucLayoutIndex[nds.hres_mode] += 1;
-                }
-/*
-                if (nds.hres_mode == 0) {
-                    //if (nds.dis_mode < NDS_DIS_MODE_LAST) {
-                    if (nds.dis_mode < getmax_layout(nds.hres_mode)) {
-                        nds.dis_mode += 1;
-                    }
+                printf(PREFIX"HOTKEY: LAYOUT_INC idx=%d->", g_advdrastic.ucLayoutIndex[0]);
+                if (g_advdrastic.ucLayoutIndex[0] < (getmax_layout(0)-1)) {
+                    g_advdrastic.ucLayoutIndex[0] += 1;
                 }
-                else {
-                    nds.dis_mode = NDS_DIS_MODE_HRES1;
-                }
-*/
-                backup_input = g_advdrastic.ulInput;   
-                goto LAB_000986b4; 	
+                printf("%d max=%d\n", g_advdrastic.ucLayoutIndex[0], getmax_layout(0));
+                need_reload_bg = RELOAD_BG_COUNT;
+                backup_input = g_advdrastic.ulInput;
+                goto LAB_000986b4;
             }
             else if (g_advdrastic.ulInput & (1L << (0x29 + ADVANCE_CONTROL_INDEX_HOT_CUSTOM_SETTING))) {
                 g_advdrastic.ulInput = 0;
@@ -2582,21 +2632,19 @@
                 goto LAB_000986b4;
             }
             else if (g_advdrastic.ulInput & (1L << (0x29 + ADVANCE_CONTROL_INDEX_HOT_CHANGE_THEME))) {
-                ucLayoutType = getlayout_type(nds.hres_mode, g_advdrastic.ucLayoutIndex[nds.hres_mode]);
+                ucLayoutType = getlayout_type(0, g_advdrastic.ucLayoutIndex[0]);
+                printf(PREFIX"HOTKEY: THEME mode=%d layoutType=%d sel=%d max=%d\n", evt.mode, ucLayoutType, nds.theme.sel, nds.theme.max);
                 if (evt.mode == MMIYOO_KEYPAD_MODE) {
-                    if (/*(nds.overlay.sel >= nds.overlay.max) && */
-                        (ucLayoutType != LAYOUT_TYPE_TRANSPARENT) &&
-                        (ucLayoutType != LAYOUT_TYPE_HIGHRESOLUTION) &&
-                        (ucLayoutType != LAYOUT_TYPE_SINGLE) 
-  /*                      (nds.dis_mode != NDS_DIS_MODE_VH_T0) &&
-                        (nds.dis_mode != NDS_DIS_MODE_VH_T1) &&
-                        (nds.dis_mode != NDS_DIS_MODE_S1) &&
-                        (nds.dis_mode != NDS_DIS_MODE_HRES1) */
-                        ) {
+                    // Allow theme change for all layout types except transparent and rotated
+                    if ((ucLayoutType != LAYOUT_TYPE_TRANSPARENT)) {
                         nds.theme.sel+= 1;
                         if (nds.theme.sel > nds.theme.max) {
                             nds.theme.sel = 0;
                         }
+                        printf(PREFIX"HOTKEY: THEME changed to %d\n", nds.theme.sel);
+                        need_reload_bg = RELOAD_BG_COUNT;
+                    } else {
+                        printf(PREFIX"HOTKEY: THEME blocked by layoutType=%d\n", ucLayoutType);
                     }
                 }
                 else {
@@ -4016,21 +4064,22 @@
 			} while (uVar4 != 0x29);
             
             // 추가 키맵
+            printf(PREFIX"Advanced controls map (uVar4 starts at 0x%x):\n", uVar4);
             for (i=0; i<NUM_OF_ADVANCE_CONTROL_INDEX; i++) {
  				uVar1 = g_advControls[i].a;
 				if (uVar1 != 0xffff) {
 					*(ulong *)((long)__s + (ulong)uVar1 * 8) =
 						*(ulong *)((long)__s + (ulong)uVar1 * 8) | 1L << (uVar4 & 0x3f);
-                    //printf("[trngaje] input_a(%d):%p\n", uVar4, *(ulong *)((long)__s + (ulong)uVar1 * 8) );
+                    printf(PREFIX"  adv_a[%d]: code=0x%x bit=%d map=0x%lx\n", i, uVar1, uVar4, *(ulong *)((long)__s + (ulong)uVar1 * 8));
 				}
 				uVar1 = g_advControls[i].b;
 				if (uVar1 != 0xffff) {
 					*(ulong *)((long)__s + (ulong)uVar1 * 8) =
 						*(ulong *)((long)__s + (ulong)uVar1 * 8) | 1L << (uVar4 & 0x3f);
-                    //printf("[trngaje] input_b(%d):%p\n", uVar4, *(ulong *)((long)__s + (ulong)uVar1 * 8) );
+                    printf(PREFIX"  adv_b[%d]: code=0x%x bit=%d map=0x%lx\n", i, uVar1, uVar4, *(ulong *)((long)__s + (ulong)uVar1 * 8));
 				}
 				uVar4 = uVar4 + 1;
-            }   
+            }
 			uVar5 = 0;
 		}
 	}
@@ -4428,11 +4477,11 @@
     
 	lVar11 = *(long *)(param_1 + 8);
 	ppcVar1 = (unsigned char **)malloc(0x30);
-	*(unsigned long *)((long)ppcVar1 + 0x14) = 10+1;
+	*(unsigned long *)((long)ppcVar1 + 0x14) = 10;
 	*ppcVar1 = draw_menu_main;
 	ppcVar1[1] = (unsigned char *)0x0;
 	ppcVar1[5] = (unsigned char *)0x0;
-	pcVar2 = (unsigned char *)malloc(0x50+8);
+	pcVar2 = (unsigned char *)malloc(0x50);
 	ppcVar1[4] = pcVar2;
 	pcVar3 = (char *)create_menu_options(param_1,ppcVar1);
 	pcVar4 = (char *)create_menu_controls(param_1,ppcVar1);
@@ -4458,47 +4507,33 @@
 	ppcVar6[6] = pcVar3;
-	*puVar10 = ppcVar6;
+	puVar10[2] = ppcVar6;
     // -----------------------------------------------------------------------
-    // add Change Steward Options
- 	ppcVar6 = (char **)malloc(0x38);
-	ppcVar8 = ppcVar6;
-	if (ppcVar6 == (char **)0x0) {
-		ppcVar8 = (char **)malloc(0x30);
-	}
-	*ppcVar8 = "Change Steward Options";
-	*(unsigned int *)(ppcVar8 + 1) = 0x23+1; // 45
-	ppcVar8[2] = (char *)draw_menu_option;
-	ppcVar8[3] = (char *)action_select;
-	ppcVar8[4] = (char *)0x0;
-	ppcVar8[5] = (char *)0x0;
-	ppcVar6[6] = display_custom_setting; 
-	puVar10[1] = ppcVar6;
-    // -----------------------------------------------------------------------
 	ppcVar6 = (char **)malloc(0x38);
 	ppcVar8 = ppcVar6;
 	if (ppcVar6 == (char **)0x0) {
 		ppcVar8 = (char **)malloc(0x30);
 	}
-	*(unsigned int *)(ppcVar8 + 1) = 0x24+1;
+	*(unsigned int *)(ppcVar8 + 1) = 0x24;
 	*ppcVar8 = "Configure Controls";
 	ppcVar8[2] = (char *)draw_menu_option;
 	ppcVar8[3] = (char *)action_select_menu;
 	ppcVar8[4] = (char *)0x0;
 	ppcVar8[5] = (char *)destroy_select_menu;
 	ppcVar6[6] = pcVar4;
-	puVar10[1+1] = ppcVar6;
+	puVar10[3] = ppcVar6;
 	ppcVar6 = (char **)malloc(0x38);
 	ppcVar8 = ppcVar6;
 	if (ppcVar6 == (char **)0x0) {
 		ppcVar8 = (char **)malloc(0x30);
 	}
-	*(unsigned int *)(ppcVar8 + 1) = 0x25+1;
+	*(unsigned int *)(ppcVar8 + 1) = 0x25;
 	*ppcVar8 = "Configure Firmware";
 	ppcVar8[2] = (char *)draw_menu_option;
 	ppcVar8[3] = (char *)action_select_menu;
 	ppcVar8[4] = (char *)0x0;
 	ppcVar8[5] = (char *)destroy_select_menu;
 	ppcVar6[6] = pcVar5;
-	puVar10[2+1] = ppcVar6;
+	puVar10[4] = ppcVar6;
 	ppcVar6 = (char **)malloc(0x38);
 	ppcVar8 = ppcVar6;
 	if (ppcVar6 == (char **)0x0) {
@@ -4506,13 +4540,13 @@
 	}
 	*ppcVar8 = "Configure Cheats";
 	pcVar3 = (char *)(lVar11 + 0x458);
-	*(unsigned int *)(ppcVar8 + 1) = 0x26+1;
+	*(unsigned int *)(ppcVar8 + 1) = 0x26;
 	ppcVar8[2] = (char *)draw_menu_option;
 	ppcVar8[3] = (char *)action_select;
 	ppcVar8[4] = (char *)0x0;
 	ppcVar8[5] = (char *)0x0;
 	ppcVar6[6] = (char *)select_cheat_menu;
-	puVar10[3+1] = ppcVar6;
+	puVar10[5] = ppcVar6;
 	ppcVar7 = (char **)malloc(0x50);
 	ppcVar8 = ppcVar7;
 	ppcVar6 = ppcVar7;
@@ -4532,7 +4566,7 @@
 	ppcVar7[4] = (char *)focus_savestate;
 	ppcVar7[8] = (char *)modify_snapshot_bg;
 	ppcVar7[9] = (char *)select_load_state;
-	puVar10[4+1] = ppcVar7;
+	puVar10[0] = ppcVar7;
 	ppcVar7 = (char **)malloc(0x50);
 	ppcVar8 = ppcVar7;
 	ppcVar6 = ppcVar7;
@@ -4552,7 +4586,7 @@
 	ppcVar7[4] = (char *)focus_savestate;
 	ppcVar7[8] = (char *)modify_snapshot_bg;
 	ppcVar7[9] = (char *)select_save_state;
-	puVar10[5+1] = ppcVar7;
+	puVar10[1] = ppcVar7;
 	ppcVar6 = (char **)malloc(0x38);
 	ppcVar8 = ppcVar6;
 	if (ppcVar6 == (char **)0x0) {
@@ -4565,7 +4599,7 @@
 	ppcVar8[4] = (char *)0x0;
 	ppcVar8[5] = (char *)0x0;
 	ppcVar6[6] = (char *)select_load_game;
-	puVar10[6+1] = ppcVar6;
+	puVar10[6] = ppcVar6;
 	ppcVar6 = (char **)malloc(0x38);
 	ppcVar8 = ppcVar6;
 	if (ppcVar6 == (char **)0x0) {
@@ -4578,7 +4612,7 @@
 	ppcVar8[4] = (char *)0x0;
 	ppcVar8[5] = (char *)0x0;
 	ppcVar6[6] = (char *)select_restart;
-	puVar10[7+1] = ppcVar6;
+	puVar10[7] = ppcVar6;
 	ppcVar6 = (char **)malloc(0x38);
 	ppcVar8 = ppcVar6;
 	if (ppcVar6 == (char **)0x0) {
@@ -4591,7 +4625,7 @@
 	ppcVar8[4] = (char *)0x0;
 	ppcVar8[5] = (char *)0x0;
 	ppcVar6[6] = (char *)select_return;
-	puVar10[8+1] = ppcVar6;
+	puVar10[8] = ppcVar6;
 	ppcVar6 = (char **)malloc(0x38);
 	ppcVar8 = ppcVar6;
 	if (ppcVar6 == (char **)0x0) {
@@ -4605,7 +4639,7 @@
 	ppcVar8[4] = (char *)0x0;
 	ppcVar8[5] = (char *)0x0;
 	ppcVar6[6] = (char *)select_quit;
-	puVar10[9+1] = ppcVar6;
+	puVar10[9] = ppcVar6;
 	return ppcVar1;
 }
 
@@ -6607,7 +6641,7 @@
     glLinkProgram(vid.pObject);
     glUseProgram(vid.pObject);
 
-    eglSwapInterval(vid.eglDisplay, 1);
+    eglSwapInterval(vid.eglDisplay, 0); // DRM page flip handles vsync
     vid.posLoc = glGetAttribLocation(vid.pObject, "a_position");
     vid.texLoc = glGetAttribLocation(vid.pObject, "a_texCoord");
     vid.samLoc = glGetUniformLocation(vid.pObject, "s_texture");
@@ -6773,6 +6807,14 @@
     // 1:1 ratio 기기에서 좌우 글자 겹침 때문에 아래 구문 추가함
     FONT_SIZE= (g_advdrastic.iDisplay_height * 24 / 480 <= g_advdrastic.iDisplay_width * 24 / 640) ?  g_advdrastic.iDisplay_height * 24 / 480 : g_advdrastic.iDisplay_width * 24 / 640;  
     nds.font = TTF_OpenFont(FONT_PATH, FONT_SIZE);
+    if (!nds.font) {
+        printf(PREFIX"ERROR: TTF_OpenFont(%s, %d) failed: %s\n", FONT_PATH, FONT_SIZE, TTF_GetError());
+        // Try fallback to original font
+        nds.font = TTF_OpenFont("resources/font/font_original.ttf", FONT_SIZE);
+        if (!nds.font) {
+            printf(PREFIX"ERROR: Fallback font also failed: %s\n", TTF_GetError());
+        }
+    }
     if (nds.enable_752x560) {
         //TTF_SetFontStyle(nds.font, TTF_STYLE_BOLD);
     }
@@ -7059,6 +7101,14 @@
     struct gbm_bo *bo;
     uint32_t handle, pitch, fb;
 
+    // Wait for previous page flip to complete (non-blocking if already done)
+    while (pflip_pending) {
+        struct pollfd pfd = { .fd = dri_fd, .events = POLLIN };
+        if (poll(&pfd, 1, 100) > 0) {
+            drmHandleEvent(dri_fd, &drm_evctx);
+        }
+    }
+
     // Lock the front buffer AFTER swap (not before)
     bo = gbm_surface_lock_front_buffer(drm_buf.gbm_surface);
     handle = gbm_bo_get_handle(bo).u32;
@@ -7067,8 +7117,13 @@
     drmModeAddFB(dri_fd, drm_buf.width, drm_buf.height,
                  24, 32, pitch, handle, &fb);
 
-    drmModeSetCrtc(dri_fd, crtc_id, fb,
-			0, 0, &conn_id, 1, &conn->modes[0]);
+    // Async page flip — returns immediately, flip happens at next vblank
+    if (drmModePageFlip(dri_fd, crtc_id, fb, DRM_MODE_PAGE_FLIP_EVENT, NULL)) {
+        // Fallback to synchronous SetCrtc if PageFlip not supported
+        drmModeSetCrtc(dri_fd, crtc_id, fb, 0, 0, &conn_id, 1, &conn->modes[0]);
+    } else {
+        pflip_pending = 1;
+    }
 
     if (drm_buf.previous_bo) {
         drmModeRmFB(dri_fd, drm_buf.fb_id);
@@ -7285,7 +7340,6 @@
     sprintf(buf, "%s/%s", folder, MENU_CURSOR_FILE);
     nds.menu.cursor = IMG_Load(buf);
 
-/*
     sprintf(buf, "%s/%s", folder, DRASTIC_MENU_BG0_FILE);
     t = IMG_Load(buf);
     if (t) {
@@ -7305,7 +7359,6 @@
         nds.menu.drastic.bg1 = SDL_ConvertSurface(t, cvt->format, 0);
         SDL_FreeSurface(t);
     }
-*/
     sprintf(buf, "%s/%s", folder, DRASTIC_MENU_CURSOR_FILE);
     nds.menu.drastic.cursor = IMG_Load(buf);
 
@@ -7546,7 +7599,7 @@
     //detour_hook(FUN_SET_SCREEN_ORIENTATION, (intptr_t)sdl_setscreen_orientation);
     detour_hook(FUN_UPDATE_INPUT, (intptr_t)sdl_update_input);
     detour_hook(FUN_UPDATE_SCREEN_MENU, (intptr_t)sdl_update_screen_menu);
-    //detour_hook(FUN_GET_GUI_INPUT, (intptr_t)sdl_get_gui_input);
+    detour_hook(FUN_GET_GUI_INPUT, (intptr_t)sdl_get_gui_input);
     detour_hook(FUN_DRAW_MENU_BG, (intptr_t)sdl_draw_menu_bg);
     detour_hook(FUN_QUIT, (intptr_t)sdl_quit);
     detour_hook(FUN_PLATFORM_GET_INPUT, (intptr_t)sdl_platform_get_input);
